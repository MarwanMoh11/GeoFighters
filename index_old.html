
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Geometry Fighters</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="ui-container">
        <div id="gameUi" style="display: none;">
            <div id="info">
                Shield: <span id="shield">100</span><br>
                Score: <span id="score">0</span><br>
                Shapes: <span id="shapeCount">0</span>
            </div>
            <div id="timer">00:00</div>
            <div id="levelText">Level: <span id="level">1</span></div>
            <div id="xpBar"><div id="xpBarFill"></div></div>
            <div class="indicator-container">
                <div id="weaponIndicator"></div>
                <div id="itemIndicator"></div>
            </div>
            <button id="fullscreen-button">Fullscreen</button>
            <div id="damage-numbers-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none;"></div>
        </div>

        <div id="mainMenu" class="menu-overlay" style="display: flex;"> <div class="menu-box"> <h1>Geometry Fighters</h1> <button onclick="showLevelSelect()">Start Simulation</button> <button onclick="showUpgradeMenu()">Meta Upgrades</button> <button onclick="showSettings('MainMenu')">Settings</button> </div> </div>
        <div id="upgradeMenu" class="menu-overlay">
            <div class="menu-box">
                <h2>Meta Upgrades</h2>
                <div id="currencyDisplay">Data Cores: <span id="coresAmount">0</span></div>
                <div id="metaUpgradeList">
                    <!-- Upgrades will be populated by JS -->
                </div>
                <button onclick="applyMetaUpgradesAndReturn()">Apply & Back</button>
            </div>
        </div>
        <div id="levelSelectMenu" class="menu-overlay"> <div class="menu-box"> <h2>Select Level</h2> <div id="levelList"></div> <button onclick="hideLevelSelect()">Back to Main Menu</button> </div> </div>
        <div id="pauseMenu" class="menu-overlay"> <div class="menu-box"> <h2>Paused</h2> <button onclick="resumeGame()">Resume</button> <button onclick="showEvolutionBook()">Evolutions</button> <button onclick="showSettings('Paused')">Settings</button> <button onclick="quitToMainMenu()">Exit Simulation</button> </div> </div>
        <div id="settingsMenu" class="menu-overlay"> <div class="menu-box"> <h2>Settings</h2> <div class="settings-content"> <strong>Controls:</strong><br> WASD / Arrow Keys: Move Fighter<br> Mouse: Aim Modules<br> P / Escape: Pause Simulation<br><br> <strong>Touch Controls (Mobile):</strong><br> Left Screen: Virtual Joystick for Movement<br> Right Screen: Virtual Joystick for Aiming </div> <button onclick="hideSettings()">Back</button> </div> </div>
        <div id="evolutionBookMenu" class="menu-overlay"> <div class="menu-box"> <h2>Evolution Guide</h2> <div id="evolutionList"></div> <button onclick="hideEvolutionBook()">Back to Pause Menu</button> </div> </div>
        <div id="gameOver" class="popup-overlay"> SIMULATION FAILED!<br> Final Score: <span id="finalScore">0</span><br> <button onclick="quitToMainMenu()">Return to Menu</button> </div>
        <div id="winScreen" class="popup-overlay"> SIMULATION COMPLETE!<br> You Survived 30 Minutes!<br> Final Score: <span id="winFinalScore">0</span><br> <button onclick="quitToMainMenu()">Return to Menu</button> </div>
        <div id="levelUpScreen" class="popup-overlay"> <h2>Upgrade Available!</h2> <div id="upgradeOptions"></div> </div>
        <div id="cacheRewardPopup"> <h3>Cache Opened!</h3> <div id="cacheRewardsList"></div> </div>
    </div>
    <div id="joystick-area"><div id="joystick-knob"></div></div>
    <div id="aim-joystick-area"><div id="aim-joystick-knob"></div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game States ---
        const GameState = { MainMenu: 'MainMenu', LevelSelect: 'LevelSelect', UpgradeMenu: 'UpgradeMenu', Playing: 'Playing', Paused: 'Paused', LevelUp: 'LevelUp', Settings: 'Settings', GameOver: 'GameOver', Win: 'Win', EvolutionBook: 'EvolutionBook' };
        let currentGameState = GameState.MainMenu;
        let previousGameState = GameState.MainMenu; // Used for returning from Settings/Book etc.
        let previousMenuState = GameState.MainMenu; // Specifically for returning from Upgrades

        // --- Audio ---
        let audioContext = null; // Initialize later after user interaction

        // --- Performance Optimization ---
        // Object pools for frequently created/destroyed objects
        const objectPools = {
            projectiles: [],
            particles: [],
            hitEffects: [],
            dataFragments: []
        };

        // Maximum pool sizes to prevent memory bloat
        const MAX_POOL_SIZE = {
            projectiles: 300,
            particles: 500,
            hitEffects: 50,
            dataFragments: 200
        };

        // Get an object from the pool or create a new one if the pool is empty
        function getFromPool(poolName, createFunc) {
            if (objectPools[poolName] && objectPools[poolName].length > 0) {
                return objectPools[poolName].pop();
            }
            return createFunc();
        }

        // Return an object to the pool if there's room, otherwise dispose of it
        function returnToPool(poolName, object, resetFunc) {
            if (!objectPools[poolName]) return;

            // Reset the object to its default state
            if (resetFunc) resetFunc(object);

            // Add to pool if there's room, otherwise let it be garbage collected
            if (objectPools[poolName].length < MAX_POOL_SIZE[poolName]) {
                objectPools[poolName].push(object);
            } else {
                // If we're disposing, make sure to clean up THREE.js resources
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(m => m && m.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            }
        }

        // --- Frustum Culling ---
        // Create a frustum to check if objects are visible
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();

        // Update the frustum based on the camera
        function updateFrustum() {
            if (!camera) return;

            camera.updateMatrixWorld(); // Make sure camera matrix is up to date
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);
        }

        // Check if an object is visible in the frustum
        function isVisible(object, extraRadius = 0) {
            if (!object || !object.position) return false;

            // For simple objects, just check if the position is in the frustum
            // with an extra radius for safety
            return frustum.containsPoint(object.position) || 
                   (extraRadius > 0 && (
                       frustum.containsPoint(new THREE.Vector3(object.position.x + extraRadius, object.position.y, object.position.z)) ||
                       frustum.containsPoint(new THREE.Vector3(object.position.x - extraRadius, object.position.y, object.position.z)) ||
                       frustum.containsPoint(new THREE.Vector3(object.position.x, object.position.y, object.position.z + extraRadius)) ||
                       frustum.containsPoint(new THREE.Vector3(object.position.x, object.position.y, object.position.z - extraRadius))
                   ));
        }

        // --- Spatial Partitioning for Collision Detection ---
        // Grid-based spatial partitioning to reduce collision checks
        class SpatialGrid {
            constructor(cellSize = 10, worldSize = WORLD_BOUNDARY * 2) {
                this.cellSize = cellSize;
                this.worldSize = worldSize;
                this.grid = {};
                this.gridSize = Math.ceil(worldSize / cellSize);
            }

            // Clear the grid
            clear() {
                this.grid = {};
            }

            // Get cell key from position
            getCellKey(x, z) {
                const cellX = Math.floor((x + this.worldSize / 2) / this.cellSize);
                const cellZ = Math.floor((z + this.worldSize / 2) / this.cellSize);
                return `${cellX},${cellZ}`;
            }

            // Add object to grid
            addObject(object, position) {
                const key = this.getCellKey(position.x, position.z);
                if (!this.grid[key]) {
                    this.grid[key] = [];
                }
                this.grid[key].push(object);
            }

            // Get objects in cell and neighboring cells
            getObjectsNear(position, radius = 0) {
                const cellsToCheck = new Set();
                const radiusCells = Math.ceil(radius / this.cellSize);

                // Get center cell
                const centerX = Math.floor((position.x + this.worldSize / 2) / this.cellSize);
                const centerZ = Math.floor((position.z + this.worldSize / 2) / this.cellSize);

                // Add center cell and neighboring cells based on radius
                for (let x = centerX - radiusCells; x <= centerX + radiusCells; x++) {
                    for (let z = centerZ - radiusCells; z <= centerZ + radiusCells; z++) {
                        if (x >= 0 && x < this.gridSize && z >= 0 && z < this.gridSize) {
                            cellsToCheck.add(`${x},${z}`);
                        }
                    }
                }

                // Collect objects from all relevant cells
                const nearbyObjects = [];
                cellsToCheck.forEach(key => {
                    if (this.grid[key]) {
                        nearbyObjects.push(...this.grid[key]);
                    }
                });

                return nearbyObjects;
            }
        }

        // --- Basic Setup ---
        const WORLD_BOUNDARY = 70;

        // Create spatial grid for game objects
        const spatialGrid = new SpatialGrid(10, WORLD_BOUNDARY * 2);
        let scene, camera, renderer;
        let player, ground, gridHelper;
        const clock = new THREE.Clock();
        let isPaused = false;
        let gameTime = 0;
        let currentLevelId = 1;

        // --- Audio ---

        // --- Meta Progression ---
        let dataCores = 0;
        const metaUpgrades = { // Define available permanent upgrades
            maxShield: { name: "Max Shield", level: 0, maxLevel: 10, costBase: 50, costIncrease: 1.5, valuePerLevel: 10 },
            baseDamage: { name: "Base Damage", level: 0, maxLevel: 10, costBase: 75, costIncrease: 1.6, valuePerLevel: 0.05 },
            moveSpeed: { name: "Move Speed", level: 0, maxLevel: 5, costBase: 60, costIncrease: 1.8, valuePerLevel: 0.15 },
            pickupRadius: { name: "Pickup Radius", level: 0, maxLevel: 5, costBase: 40, costIncrease: 1.7, valuePerLevel: 0.2 },
            luck: { name: "Luck", level: 0, maxLevel: 10, costBase: 100, costIncrease: 1.8, valuePerLevel: 0.03 },
        };
        let baseDamageMultiplier = 1.0; // Global multiplier affected by meta upgrade

        // ... (near WORLD_BOUNDARY)
        const ENEMY_DESPAWN_DISTANCE_FACTOR = 1.2; // How many times the screen diagonal (approx) away to despawn
        const MIN_ENEMY_DESPAWN_DISTANCE = 60;  // Minimum distance regardless of screen size (prevents too close despawn on small screens)
        const MAX_ENEMY_DESPAWN_DISTANCE = 100; // Absolute max distance to despawn (prevents waiting too long on huge screens)

        // --- Player Stats & Leveling ---
        let BASE_MAX_PLAYER_SHIELD = 100; // Base value before meta upgrades
        let playerShield = 100; // <<<< DECLARED ONCE HERE
        let MAX_PLAYER_SHIELD = 100; // Current max, updated by meta upgrades
        let score = 0; // <<<< DECLARED ONCE HERE
        let playerLevel = 1; // <<<< DECLARED ONCE HERE
        let currentXP = 0; // <<<< DECLARED ONCE HERE
        let xpToNextLevel = 60; // <<<< DECLARED ONCE HERE
        const playerWeapons = []; // <<<< DECLARED ONCE HERE
        const MAX_WEAPONS = 5; // <<<< DECLARED ONCE HERE
        const playerItems = []; // <<<< DECLARED ONCE HERE
        const MAX_ITEMS = 5; // <<<< DECLARED ONCE HERE
        let playerCorruptionTimer = 0; // <<<< DECLARED ONCE HERE
        const CORRUPTION_DAMAGE = 1; // <<<< DECLARED ONCE HERE
        const CORRUPTION_INTERVAL = 0.5; // <<<< DECLARED ONCE HERE
        let corruptionEffectTimer = 0; // <<<< DECLARED ONCE HERE
        let shieldRegenTimer = 0; // <<<< DECLARED ONCE HERE

        // --- Timers ---
        let shapeSpawnTimer = 0; // <<<< DECLARED ONCE HERE
        const baseShapeSpawnInterval = 2.0; // <<<< DECLARED ONCE HERE
        let shapeSpawnInterval = baseShapeSpawnInterval; // <<<< DECLARED ONCE HERE
        let eliteSpawnTimer = 35; // <<<< DECLARED ONCE HERE
        const eliteSpawnInterval = 40; // <<<< DECLARED ONCE HERE // NOTE: You had 20 here in the duplicate block, using 40 from the first block. Adjust if needed.
        let pickupSpawnTimer = 5; // <<<< DECLARED ONCE HERE
        const pickupSpawnInterval = 8; // <<<< DECLARED ONCE HERE

        // --- Movement & Stats (Base values) ---
        const moveState = { forward: 0, backward: 0, left: 0, right: 0 };
        const basePlayerSpeed = 5.0; // <<< ADD THIS LINE BACK
        let BASE_PLAYER_SPEED = 5.0; // Base before meta upgrades - You can actually remove this one and just use basePlayerSpeed everywhere
        let playerSpeed = basePlayerSpeed; // Initialize playerSpeed with the base constant
        const baseProjectileSpeed = 10;
        const baseDataFragmentSpeed = 3.5;
        const baseXpCollectionRadius = 2.0; // Renamed BASE_XP_COLLECTION_RADIUS below
        let BASE_XP_COLLECTION_RADIUS = 2.0; // Base before meta upgrades
        let xpCollectionRadius = BASE_XP_COLLECTION_RADIUS;

        // --- Collision & Radii ---
        const playerRadius = 0.6; // <<<< DECLARED ONCE HERE
        const playerHeight = 1.0; // <<<< DECLARED ONCE HERE
        const projectileRadius = 0.1; // <<<< DECLARED ONCE HERE
        const dataFragmentRadius = 0.15; // <<<< DECLARED ONCE HERE
        const energyCoreRadius = 0.25; // <<<< DECLARED ONCE HERE
        const repairNodeRadius = 0.2; // <<<< DECLARED ONCE HERE
        const cacheRadius = 0.4; // <<<< DECLARED ONCE HERE
        const pickupCollectionRadius = 0.9; // <<<< DECLARED ONCE HERE


        // --- Mouse & Touch Aiming ---
        const mouse = new THREE.Vector2(); // <<<< DECLARED ONCE HERE
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // <<<< DECLARED ONCE HERE
        const raycaster = new THREE.Raycaster(); // <<<< DECLARED ONCE HERE
        let aimTarget = new THREE.Vector3(); // <<<< DECLARED ONCE HERE

        // --- Touch Controls ---
        const joystickArea = document.getElementById('joystick-area'); // <<<< DECLARED ONCE HERE
        const joystickKnob = document.getElementById('joystick-knob'); // <<<< DECLARED ONCE HERE
        let joystickActive = false; // <<<< DECLARED ONCE HERE
        let joystickBaseX, joystickBaseY, joystickPointerId; // <<<< DECLARED ONCE HERE
        let joystickRadius = 75; // Default, will be updated // <<<< DECLARED ONCE HERE
        let knobRadius = 30;     // Default, will be updated // <<<< DECLARED ONCE HERE

        const aimJoystickArea = document.getElementById('aim-joystick-area'); // <<<< DECLARED ONCE HERE
        const aimJoystickKnob = document.getElementById('aim-joystick-knob'); // <<<< DECLARED ONCE HERE
        let aimJoystickActive = false; // <<<< DECLARED ONCE HERE
        let aimJoystickBaseX, aimJoystickBaseY, aimJoystickPointerId; // <<<< DECLARED ONCE HERE
        let aimJoystickRadius = 75; // Default // <<<< DECLARED ONCE HERE
        let aimKnobRadius = 30;     // Default // <<<< DECLARED ONCE HERE

        const fullscreenButton = document.getElementById('fullscreen-button'); // <<<< DECLARED ONCE HERE
        let isTouchDevice = false; // <<<< DECLARED ONCE HERE


        // --- Game Elements ---
        const shapes = []; // <<<< DECLARED ONCE HERE
        const projectiles = []; // <<<< DECLARED ONCE HERE
        const dataFragments = []; // <<<< DECLARED ONCE HERE
        const megaDataFragments = []; // For consolidated XP orbs
        let accumulatedOffScreenXP = 0;
        const MEGA_XP_THRESHOLD = 300; // XP needed to spawn a mega orb
        const XP_CONSOLIDATION_DISTANCE = 55; // Fragments further than this from player get 
        const hitEffects = []; // <<<< DECLARED ONCE HERE
        const geometricCaches = []; // <<<< DECLARED ONCE HERE
        const repairNodes = []; // <<<< DECLARED ONCE HERE
        const energyCores = []; // <<<< DECLARED ONCE HERE
        const particles = []; // <<<< DECLARED ONCE HERE
        let persistentWeaponMeshes = {}; // <<<< DECLARED ONCE HERE
        const staticLevelObjects = []; // <<<< DECLARED ONCE HERE
        let backgroundPattern = null; // <<<< DECLARED ONCE HERE
        const damageNumbersContainer = document.getElementById('damage-numbers-container'); // <<<< DECLARED ONCE HERE (also declared above, ensure consistency or remove one) - KEEPING THIS ONE

        // --- DOM Elements --- Ensure these are only fetched once after the variable declarations
        const gameUiElement = document.getElementById('gameUi');
        const shieldElement = document.getElementById('shield');
        const scoreElement = document.getElementById('score');
        const shapeCountElement = document.getElementById('shapeCount');
        const levelElement = document.getElementById('level');
        const xpBarFillElement = document.getElementById('xpBarFill');
        const weaponIndicatorElement = document.getElementById('weaponIndicator');
        const itemIndicatorElement = document.getElementById('itemIndicator');
        const mainMenuElement = document.getElementById('mainMenu');
        const levelSelectMenuElement = document.getElementById('levelSelectMenu');
        const levelListElement = document.getElementById('levelList'); // Ensure this is fetched before use
        const pauseMenuElement = document.getElementById('pauseMenu');
        const settingsMenuElement = document.getElementById('settingsMenu');
        const evolutionBookMenuElement = document.getElementById('evolutionBookMenu');
        const evolutionListElement = document.getElementById('evolutionList'); // Ensure this is fetched before use
        const gameOverElement = document.getElementById('gameOver');
        const levelUpScreenElement = document.getElementById('levelUpScreen');
        const upgradeOptionsElement = document.getElementById('upgradeOptions'); // Ensure this is fetched before use
        const finalScoreElement = document.getElementById('finalScore');
        const cacheRewardPopupElement = document.getElementById('cacheRewardPopup');
        const cacheRewardsListElement = document.getElementById('cacheRewardsList'); // Ensure this is fetched before use
        const timerElement = document.getElementById('timer');
        const winScreenElement = document.getElementById('winScreen');
        const winFinalScoreElement = document.getElementById('winFinalScore');
        const upgradeMenuElement = document.getElementById('upgradeMenu');
        const metaUpgradeListElement = document.getElementById('metaUpgradeList');
        const coresAmountElement = document.getElementById('coresAmount');





        // --- Level Definitions ---
        const gameLevels = [ // <<< DECLARED AGAIN - REMOVE
            { id: 1, name: "Sector Prime", description: "The starting point. Anomalies are relatively sparse.", unlocked: true, mapSetup: setupLevel1Map },
            { id: 2, name: "Crystalline Maze", description: "Denser formations and more aggressive geometries.", unlocked: false, mapSetup: null },
            { id: 3, name: "The Void Edge", description: "Unstable energies and powerful entities.", unlocked: false, mapSetup: null },
        ];

        // --- Helper: Calculate Stat Modifier from Items ---
        function getItemModifier(buffType) {
            let modifier = { percent: 1.0, flat: 0.0, count: 0 };
            playerItems.forEach(item => {
                if (item.level > 0 && item.buffType === buffType) {
                    const value = item.level * item.valuePerLevel;
                    if (buffType.includes('_PERCENT')) {
                        modifier.percent += value;
                    } else if (buffType.includes('_COUNT')) {
                        modifier.count += Math.floor(value);
                    } else {
                        modifier.flat += value;
                    }
                }
            });
            return modifier;
        }

        // --- Generic Projectile Firing Function ---
        function fireGenericProjectile(weapon, options = {}) {
            if (!player) return;
            const projSpeedMod = getItemModifier('PROJECTILE_SPEED_PERCENT');
            const globalDmgMod = getItemModifier('GLOBAL_DAMAGE_PERCENT');
            const heavyDmgMod = getItemModifier('HEAVY_DAMAGE_PERCENT');
            const singleShotDmgMod = getItemModifier('SINGLE_SHOT_DAMAGE_PERCENT');
            const scatterCountMod = getItemModifier('SCATTER_COUNT');
            const aoeRadiusMod = getItemModifier('AOE_RADIUS_PERCENT');

            const speed = (options.speed || baseProjectileSpeed) * projSpeedMod.percent;
            let damage = weapon.getDamage?.() || options.damage || 10;
            damage *= globalDmgMod.percent;
            if (weapon.tags?.includes('heavy')) damage *= heavyDmgMod.percent;
            if (weapon.tags?.includes('single_shot')) damage *= singleShotDmgMod.percent;

            let count = weapon.getProjectileCount?.() || options.count || 1;
            if (weapon.tags?.includes('scatter')) count += scatterCountMod.count;

            let radius = weapon.getRadius?.() || options.radius || projectileRadius;
            if (weapon.tags?.includes('aoe')) radius *= aoeRadiusMod.percent;

            // Cache geometries and materials for reuse
            if (!window.cachedProjectileGeometries) {
                window.cachedProjectileGeometries = {};
                window.cachedProjectileMaterials = {};
            }

            // Create or get cached geometry
            let geometryKey = 'default';
            if (options.geometry) {
                // For custom geometries, we'll still create new ones as they vary widely
                geometryKey = 'custom';
            }

            if (!window.cachedProjectileGeometries[geometryKey]) {
                window.cachedProjectileGeometries[geometryKey] = options.geometry || new THREE.SphereGeometry(projectileRadius, 6, 6);
            }
            const projectileGeometry = window.cachedProjectileGeometries[geometryKey];

            // Create or get cached material
            let materialKey = options.color || 'default';
            if (options.material) {
                materialKey = 'custom';
            }

            if (!window.cachedProjectileMaterials[materialKey]) {
                if (options.material) {
                    window.cachedProjectileMaterials[materialKey] = options.material;
                } else if (options.emissiveColor || options.emissiveIntensity) {
                    window.cachedProjectileMaterials[materialKey] = new THREE.MeshStandardMaterial({
                        color: options.color || 0xffffff,
                        emissive: options.emissiveColor || options.color || 0xffffff,
                        emissiveIntensity: options.emissiveIntensity || 0.5
                    });
                } else {
                    window.cachedProjectileMaterials[materialKey] = new THREE.MeshBasicMaterial({ color: options.color || 0xffffff });
                }
            }
            const projectileMaterial = window.cachedProjectileMaterials[materialKey];

            const spread = options.spread || 0;
            const baseDir = options.direction || new THREE.Vector3().subVectors(aimTarget, player.position).normalize();
            baseDir.y = 0;

            for (let i = 0; i < count; i++) {
                const currentAngle = (count === 1) ? 0 : (-spread / 2) + (i / (count - 1)) * spread;
                const velocity = baseDir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), currentAngle).normalize().multiplyScalar(speed);

                // Get projectile mesh from pool or create new one
                const projectileMesh = getFromPool('projectiles', () => {
                    return new THREE.Mesh(projectileGeometry, projectileMaterial);
                });

                // If the mesh already exists but has different geometry/material, update it
                if (projectileMesh.geometry !== projectileGeometry) {
                    projectileMesh.geometry = projectileGeometry;
                }
                if (projectileMesh.material !== projectileMaterial) {
                    projectileMesh.material = projectileMaterial;
                }

                const startOffset = velocity.clone().normalize().multiplyScalar(playerRadius + projectileRadius + 0.1);
                projectileMesh.position.copy(player.position).add(startOffset);
                projectileMesh.position.y = playerHeight * 0.25;

                // Reset any properties that might have been modified
                projectileMesh.scale.set(1, 1, 1);
                projectileMesh.visible = true;

                const projectileData = { 
                    mesh: projectileMesh, 
                    velocity: velocity, 
                    damage: damage, 
                    weaponId: weapon.id, 
                    onHit: options.onHit, 
                    duration: options.duration, 
                    tags: weapon.tags, 
                    hitEnemies: new Set() 
                };
                projectiles.push(projectileData);

                // Add to scene if not already there
                if (!projectileMesh.parent) {
                    scene.add(projectileMesh);
                }
            }
        }

        // --- Audio --- NEW/MODIFIED FUNCTIONS
        function initializeAudio() {
            // Check if context already exists or is supported
            if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Resume context if it starts suspended (required by browser autoplay policies)
                if (audioContext.state === 'suspended') {
                    const resumeAudio = () => {
                        if (audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log("AudioContext resumed successfully.");
                                // Remove listeners once resumed
                                document.body.removeEventListener('click', resumeAudio);
                                document.body.removeEventListener('touchstart', resumeAudio);
                                document.body.removeEventListener('keydown', resumeAudio);
                            }).catch(e => console.error("Error resuming AudioContext:", e));
                        } else {
                            // Already running, remove listeners
                            document.body.removeEventListener('click', resumeAudio);
                            document.body.removeEventListener('touchstart', resumeAudio);
                            document.body.removeEventListener('keydown', resumeAudio);
                        }
                    };
                    // Need user interaction to resume
                    document.body.addEventListener('click', resumeAudio, { once: true });
                    document.body.addEventListener('touchstart', resumeAudio, { once: true });
                    document.body.addEventListener('keydown', resumeAudio, { once: true });
                }
                console.log("AudioContext initialized.");
            } else if (!window.AudioContext && !window.webkitAudioContext) {
                console.warn("Web Audio API not supported by this browser.");
            }
        }

        function playSoundSynth(type = 'hit', volume = 0.3, options = {}) {
            if (!audioContext || audioContext.state !== 'running') {
                // console.warn("AudioContext not running, cannot play sound:", type);
                return; // Need running context
            }

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            // Apply overall volume adjustment
            gain.gain.setValueAtTime(volume * 0.8, now); // Start slightly quieter than max specified volume

            switch (type) {
                case 'shoot_basic':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(options.pitch || 660, now); // E5
                    osc.frequency.exponentialRampToValueAtTime(330, now + 0.1); // Pitch down quickly
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'enemy_hit':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(options.pitch || 220, now); // A3
                    osc.frequency.linearRampToValueAtTime(110, now + 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                    osc.start(now);
                    osc.stop(now + 0.08);
                    break;
                case 'enemy_death':
                    osc.type = 'sawtooth';
                    const basePitch = options.isLarge ? 100 : 150;
                    osc.frequency.setValueAtTime(basePitch, now);
                    osc.frequency.exponentialRampToValueAtTime(basePitch * 0.5, now + 0.2);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    // Add noise burst for texture
                    const noiseSource = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, Math.floor(audioContext.sampleRate * 0.15), audioContext.sampleRate); // Use floor
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < output.length; i++) { output[i] = Math.random() * 2 - 1; }
                    noiseSource.buffer = noiseBuffer;
                    const noiseGain = audioContext.createGain();
                    noiseGain.gain.setValueAtTime(volume * 0.4, now); // Noise volume relative to main volume
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    noiseSource.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    noiseSource.start(now);
                    noiseSource.stop(now + 0.15);
                    break;
                case 'player_hit':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(180, now);
                    osc.frequency.setValueAtTime(160, now + 0.05); // Wobble
                    osc.frequency.setValueAtTime(180, now + 0.1);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                case 'pickup_xp':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(options.pitch || 880, now); // A5 or options
                    osc.frequency.linearRampToValueAtTime((options.pitch || 880) * 1.5, now + 0.08); // Pitch up 50%
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                    osc.start(now);
                    osc.stop(now + 0.08);
                    break;
                case 'pickup_health':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523.25, now); // C5
                    osc.frequency.setValueAtTime(659.25, now + 0.1); // E5
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
                case 'level_up':
                    const baseFreq = 261.63; // C4
                    const freqs = [baseFreq, baseFreq * 1.2599, baseFreq * 1.4983, baseFreq * 2]; // C, E, G, C (approx equal temperament)
                    const dur = 0.12;
                    freqs.forEach((freq, i) => {
                        const oscL = audioContext.createOscillator();
                        const gainL = audioContext.createGain();
                        oscL.type = 'triangle';
                        oscL.frequency.setValueAtTime(freq, now + i * dur);
                        gainL.gain.setValueAtTime(volume * 0.5, now + i * dur);
                        gainL.gain.exponentialRampToValueAtTime(0.001, now + (i + 0.9) * dur); // Slightly faster fade
                        oscL.connect(gainL);
                        gainL.connect(audioContext.destination);
                        oscL.start(now + i * dur);
                        oscL.stop(now + (i + 1) * dur);
                    });
                    break;
                case 'cache_open':
                    // Longer noise burst + rising synth tone
                    const noiseCache = audioContext.createBufferSource();
                    // Longer duration, ensure integer sample count
                    const noiseCacheBuffer = audioContext.createBuffer(1, Math.floor(audioContext.sampleRate * 0.5), audioContext.sampleRate);
                    const noiseCacheOutput = noiseCacheBuffer.getChannelData(0);
                    for (let i = 0; i < noiseCacheOutput.length; i++) { noiseCacheOutput[i] = Math.random() * 2 - 1; }
                    noiseCache.buffer = noiseCacheBuffer;
                    const noiseCacheGain = audioContext.createGain();
                    noiseCacheGain.gain.setValueAtTime(volume * 0.5, now);
                    noiseCacheGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    noiseCache.connect(noiseCacheGain);
                    noiseCacheGain.connect(audioContext.destination);
                    noiseCache.start(now);
                    noiseCache.stop(now + 0.5);
                    // Synth tone
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.4);
                    gain.gain.setValueAtTime(volume * 0.4, now);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                case 'upgrade_buy':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(783.99, now); // G5
                    osc.frequency.linearRampToValueAtTime(1046.50, now + 0.1); // C6
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'error':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                default: // Default hit sound if type unknown
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, now); // A4
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
            }
        }


        // --- Save/Load ---
        function saveData() {
            try {
                const gameData = {
                    dataCores: dataCores,
                    metaUpgrades: {}
                };
                // Store only the level for each meta upgrade
                for (const key in metaUpgrades) {
                    if (metaUpgrades.hasOwnProperty(key)) {
                        gameData.metaUpgrades[key] = metaUpgrades[key].level;
                    }
                }
                localStorage.setItem('geometryFightersSaveData', JSON.stringify(gameData));
                // console.log("Game data saved."); // Optional log
            } catch (e) {
                console.error("Error saving game data to localStorage:", e);
            }
        }

        function loadGameData() {
            try {
                const savedData = localStorage.getItem('geometryFightersSaveData');
                if (savedData) {
                    const gameData = JSON.parse(savedData);
                    dataCores = gameData.dataCores || 0; // Load currency, default to 0 if missing

                    // Load meta upgrade levels
                    if (gameData.metaUpgrades) {
                        for (const key in metaUpgrades) {
                            // Check if the key exists in saved data and in our current definition
                            if (metaUpgrades.hasOwnProperty(key) && gameData.metaUpgrades.hasOwnProperty(key)) {
                                // Ensure loaded level is within bounds
                                metaUpgrades[key].level = Math.max(0, Math.min(gameData.metaUpgrades[key] || 0, metaUpgrades[key].maxLevel));
                            } else {
                                metaUpgrades[key].level = 0; // Default to 0 if not found in save
                            }
                        }
                    } else {
                        // If no metaUpgrades object in save, reset all to 0
                        for (const key in metaUpgrades) { metaUpgrades[key].level = 0; }
                    }
                    console.log("Game data loaded.");
                } else {
                    console.log("No save data found, starting fresh.");
                    // Ensure all meta upgrades start at level 0 if no save exists
                    for (const key in metaUpgrades) { metaUpgrades[key].level = 0; }
                }
            } catch (e) {
                console.error("Error loading or parsing game data from localStorage:", e);
                // Reset to defaults on error
                dataCores = 0;
                for (const key in metaUpgrades) { metaUpgrades[key].level = 0; }
            }
            // Always apply the loaded (or default) state to the game stats
            applyMetaUpgradesToGame();
        }

        function applyMetaUpgradesToGame() {
            // Calculate current max shield based on base and meta upgrade level
            MAX_PLAYER_SHIELD = BASE_MAX_PLAYER_SHIELD + (metaUpgrades.maxShield.level * metaUpgrades.maxShield.valuePerLevel);

            // Calculate current base damage multiplier
            baseDamageMultiplier = 1.0 + (metaUpgrades.baseDamage.level * metaUpgrades.baseDamage.valuePerLevel);

            // Calculate current base speed and XP radius (these become the new BASE values for the run)
            BASE_PLAYER_SPEED = 5.0 + (metaUpgrades.moveSpeed.level * metaUpgrades.moveSpeed.valuePerLevel);
            BASE_XP_COLLECTION_RADIUS = 2.0 + (metaUpgrades.pickupRadius.level * metaUpgrades.pickupRadius.valuePerLevel);

            // Note: metaUpgrades.luck is now handled inside recalculatePlayerStats for crit chance

            // Set current stats based on potentially upgraded base values
            playerShield = MAX_PLAYER_SHIELD; // Start run with full shield
            recalculatePlayerStats(); // Apply item effects ON TOP of these new base stats
            updateUI(); // Update UI to reflect potential changes (e.g., max shield if displayed)
        }


        function showUpgradeMenu() {
            initializeAudio(); // Ensure audio context is ready for UI sounds
            previousMenuState = currentGameState;
            currentGameState = GameState.UpgradeMenu;
            mainMenuElement.style.display = 'none';
            levelSelectMenuElement.style.display = 'none';
            settingsMenuElement.style.display = 'none'; // Hide other menus too
            pauseMenuElement.style.display = 'none';
            gameUiElement.style.display = 'none';
            upgradeMenuElement.style.display = 'flex'; // Show upgrade menu
            populateUpgradeMenu(); // Populate with current data
            updateJoystickVisibility();
        }

        function hideUpgradeMenu() {
            upgradeMenuElement.style.display = 'none';
            currentGameState = previousMenuState; // Return to Main Menu or wherever we came from
            // Show the correct previous menu
            if (currentGameState === GameState.MainMenu) {
                mainMenuElement.style.display = 'flex';
            } else if (currentGameState === GameState.Paused) { // Should not happen currently, but good practice
                pauseMenuElement.style.display = 'flex';
            }
            // Add other states if necessary
            updateJoystickVisibility();
        }

        function applyMetaUpgradesAndReturn() {
            applyMetaUpgradesToGame(); // Apply potentially changed stats immediately
            saveData(); // Save changes made in the upgrade menu
            hideUpgradeMenu(); // Go back to the previous menu
        }


        function calculateMetaUpgradeCost(upgradeKey) {
            const upgrade = metaUpgrades[upgradeKey];
            if (!upgrade) return Infinity; // Invalid key
            if (upgrade.level >= upgrade.maxLevel) return Infinity; // Cannot buy maxed upgrades

            // Exponential cost formula: base * (increaseFactor ^ currentLevel)
            return Math.floor(upgrade.costBase * Math.pow(upgrade.costIncrease, upgrade.level));
        }

        function populateUpgradeMenu() {
            if (!metaUpgradeListElement || !coresAmountElement) {
                console.error("Upgrade menu DOM elements not found!");
                return;
            }

            coresAmountElement.textContent = dataCores; // Display current currency
            metaUpgradeListElement.innerHTML = ''; // Clear old list

            // Iterate through defined meta upgrades
            for (const key in metaUpgrades) {
                if (metaUpgrades.hasOwnProperty(key)) {
                    const upgrade = metaUpgrades[key];
                    const cost = calculateMetaUpgradeCost(key);

                    const entryDiv = document.createElement('div');
                    entryDiv.classList.add('upgrade-stat-entry');

                    // Display Name and Level
                    const infoSpan = document.createElement('span');
                    infoSpan.textContent = `${upgrade.name} (Lvl ${upgrade.level} / ${upgrade.maxLevel})`;

                    // Display Cost or Max Level
                    const costSpan = document.createElement('span');
                    if (upgrade.level < upgrade.maxLevel) {
                        costSpan.innerHTML = `Cost: <strong>${cost}</strong>`; // Use innerHTML to render strong tag
                    } else {
                        costSpan.innerHTML = `<strong style="color: #aaffaa;">MAX</strong>`; // Style MAX differently
                    }

                    // Upgrade Button
                    const button = document.createElement('button');
                    button.textContent = "Upgrade";
                    if (upgrade.level >= upgrade.maxLevel || dataCores < cost) {
                        button.disabled = true; // Disable if maxed or cannot afford
                    }
                    // Use an anonymous function to pass the key correctly
                    button.onclick = () => buyMetaUpgrade(key);

                    entryDiv.appendChild(infoSpan);
                    const controlsDiv = document.createElement('div'); // Group cost and button for layout
                    controlsDiv.appendChild(costSpan);
                    controlsDiv.appendChild(button);
                    entryDiv.appendChild(controlsDiv);

                    metaUpgradeListElement.appendChild(entryDiv);
                }
            }
        }

        function buyMetaUpgrade(upgradeKey) {
            const upgrade = metaUpgrades[upgradeKey];
            const cost = calculateMetaUpgradeCost(upgradeKey);

            if (upgrade && dataCores >= cost && upgrade.level < upgrade.maxLevel) {
                dataCores -= cost;
                upgrade.level++;
                playSoundSynth('upgrade_buy', 0.4); // Play synth sound
                populateUpgradeMenu(); // Refresh menu to show new cost/level and update currency display
                // Note: applyMetaUpgradesToGame() is called when LEAVING the menu via applyMetaUpgradesAndReturn
            } else {
                playSoundSynth('error', 0.3); // Play synth sound
                // console.log("Cannot afford or max level reached for:", upgradeKey);
            }
        }

        // --- Damage Numbers ---
        function worldToScreen(worldVec, cameraInstance = camera, rendererInstance = renderer) {
            if (!cameraInstance || !rendererInstance) {
                // console.warn("worldToScreen: Camera or Renderer not available.");
                return null;
            }
            const vector = worldVec.clone();
            vector.project(cameraInstance); // Project 3D point to Normalized Device Coordinates (NDC)

            // Convert NDC to screen coordinates
            const screenX = Math.round((vector.x + 1) * rendererInstance.domElement.width / 2);
            const screenY = Math.round((-vector.y + 1) * rendererInstance.domElement.height / 2);

            // Check if the point is behind the camera (w component of projected vector is negative)
            // or outside the typical NDC range (though projection should handle most of this)
            if (vector.z > 1) { // vector.z in NDC is depth, > 1 means behind far plane (or sometimes just far away)
                return null; // Don't show if too far or clipped
            }

            // Get the actual world position of the camera to check if the point is behind it.
            // This is a more robust check for "behind the camera".
            const cameraWorldPos = new THREE.Vector3();
            cameraInstance.getWorldPosition(cameraWorldPos);
            const directionToPoint = new THREE.Vector3().subVectors(worldVec, cameraWorldPos);
            const cameraDirection = new THREE.Vector3();
            cameraInstance.getWorldDirection(cameraDirection);

            if (directionToPoint.dot(cameraDirection) < 0) {
                return null; // Point is behind the camera's view plane
            }

            return { x: screenX, y: screenY };
        }

        function createDamageNumber(position, amount, isCritical = false) {
            if (!damageNumbersContainer) {
                console.warn("createDamageNumber: damageNumbersContainer is not found.");
                return;
            }

            const screenPos = worldToScreen(position);
            if (!screenPos) return; // Don't create if off-screen or behind camera

            const damageText = document.createElement('div');
            damageText.classList.add('damage-number');
            if (isCritical) {
                damageText.classList.add('critical');
                damageText.textContent = `${Math.round(amount)}!!`; // Add emphasis for criticals
            } else {
                damageText.textContent = Math.round(amount);
            }

            damageText.style.left = `${screenPos.x}px`;
            damageText.style.top = `${screenPos.y}px`;

            // Initial random horizontal offset for a bit of spread
            const randomOffsetX = (Math.random() - 0.5) * 20; // Spread within +/- 10px
            damageText.style.transform = `translate(-50%, -100%) translateX(${randomOffsetX}px)`; // Center horizontally, place above point

            damageNumbersContainer.appendChild(damageText);

            // Animation: Rise up and fade out
            let currentY = 0;
            let currentOpacity = 1;
            const animationDuration = 600; // milliseconds
            const startTime = performance.now();

            function animateNumber() {
                const elapsedTime = performance.now() - startTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);

                currentY = -progress * 40; // Move up by 40px over the duration
                currentOpacity = 1 - progress * progress; // Fade out faster at the end

                damageText.style.transform = `translate(-50%, calc(-100% + ${currentY}px)) translateX(${randomOffsetX}px)`;
                damageText.style.opacity = currentOpacity;

                if (progress < 1) {
                    requestAnimationFrame(animateNumber);
                } else {
                    if (damageText.parentElement) { // Check if still attached
                        damageText.parentElement.removeChild(damageText);
                    }
                }
            }
            requestAnimationFrame(animateNumber);
        }

        // --- Fullscreen ---
        function toggleFullScreen() {
            const elem = document.documentElement; // Target the whole page

            if (!document.fullscreenElement &&
                !document.mozFullScreenElement &&
                !document.webkitFullscreenElement &&
                !document.msFullscreenElement) {
                // --- Enter Fullscreen ---
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
                // console.log("Requesting fullscreen"); // Optional log
                if (fullscreenButton) fullscreenButton.textContent = "Exit FS";
            } else {
                // --- Exit Fullscreen ---
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                // console.log("Exiting fullscreen"); // Optional log
                if (fullscreenButton) fullscreenButton.textContent = "Fullscreen";
            }
        }

        // --- Weapon/Item Upgrade Helpers ---
        function defaultApplyUpgrade() { if (this.isEvolved) return; if (this.level < this.maxLevel) this.level++; if (this.level === 1 && !playerWeapons.includes(this)) { playerWeapons.push(this); if (this.createMesh) this.createMesh(this); } else { if (this.updateMesh) this.updateMesh(this); } checkEvolution(this); updateWeaponUI(); }
        function defaultGetUpgradeDescription() { const name = `${this.name} ${this.icon}`; if (this.isEvolved) return `${name} (EVOLVED)`; if (this.level === 0) return `Acquire ${name}`; if (this.level >= this.maxLevel) return `${name} (Max Level)`; return `Upgrade ${name} (Lvl ${this.level + 1}): Improve Stats`; }
        function defaultItemApplyUpgrade() { if (this.level < this.maxLevel) this.level++; if (this.level === 1 && !playerItems.includes(this)) { playerItems.push(this); } recalculatePlayerStats(); updateItemUI(); playerWeapons.forEach(w => checkEvolution(w)); }
        function defaultItemGetUpgradeDescription() { const name = `${this.name} ${this.icon}`; if (this.level === 0) return `Acquire ${name}`; if (this.level >= this.maxLevel) return `${name} (Max Level)`; return `Upgrade ${name} (Lvl ${this.level + 1}): Enhance Effect`; }

        // --- Weapon Definitions ---
        const WEAPONS = { // Adjusted base damage/fire rate for horde mode feel
            POLY_BURST: {
                id: 'POLY_BURST', name: 'Poly Burst', icon: '', level: 0, maxLevel: 5, synergyItemId: 'KINETIC_ACCELERATOR', tags: ['aoe'], shortDescription: "Fires geometric shards radially.", baseFireRate: 0.7, baseDamage: 7, baseProjectileCount: 6, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; this.fireRadialShards(this); } },
                fireRadialShards: function (weapon) {
                    const count = weapon.getProjectileCount();
                    const damage = weapon.getDamage();
                    const shardGeometry = new THREE.TetrahedronGeometry(projectileRadius * 1.5, 0);
                    const shardMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.6 });
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const velocity = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize().multiplyScalar(baseProjectileSpeed * 0.9);
                        const projectileMesh = new THREE.Mesh(shardGeometry, shardMaterial);
                        const startOffset = velocity.clone().normalize().multiplyScalar(playerRadius + projectileRadius + 0.1);
                        projectileMesh.position.copy(player.position).add(startOffset);
                        projectileMesh.position.y = player.position.y;
                        projectiles.push({
                            mesh: projectileMesh,
                            velocity: velocity,
                            damage: damage,
                            weaponId: weapon.id,
                            tags: weapon.tags, // Make sure weapon.tags is defined for Poly Burst
                            hitEnemies: new Set() // <-- ADD THIS LINE
                        });
                        scene.add(projectileMesh);
                    }
                },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.9, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 2; }, getProjectileCount: function () { return this.baseProjectileCount + Math.floor((this.level - 1) * 0.5) * 2; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            VECTOR_LANCE: {
                id: 'VECTOR_LANCE', name: 'Vector Lance', icon: '', level: 0, maxLevel: 5, synergyItemId: 'PROJECTILE_BOOSTER', tags: ['single_shot', 'piercing'], shortDescription: "Fires sharp, piercing vector lines forward.", baseFireRate: 0.4, baseDamage: 12, baseProjectileCount: 1, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { count: this.getProjectileCount(), damage: this.getDamage(), color: 0xff8800, emissiveColor: 0xffaa00, emissiveIntensity: 0.4, geometry: new THREE.CylinderGeometry(projectileRadius * 0.2, projectileRadius * 0.2, projectileRadius * 6, 4), spread: Math.PI / 18 * (this.getProjectileCount() - 1), tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.92, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 4; }, getProjectileCount: function () { return this.baseProjectileCount + Math.floor((this.level - 1) / 2); }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            ORBITAL_SHIELD: {
                id: 'ORBITAL_SHIELD', name: 'Orbital Shield', icon: '', level: 0, maxLevel: 5, synergyItemId: 'ORBITAL_ENHANCER', tags: ['aoe', 'orbital'], shortDescription: "Spinning geometric shapes damage nearby enemies.", baseDamage: 5, baseRadius: playerRadius + 1.2, baseRotationSpeed: Math.PI * 0.6, baseShapeCount: 3, damageInterval: 0.25, damageTimer: 0, enemiesHitThisInterval: [], isEvolved: false,
                fire: function (deltaTime) { this.damageTimer += deltaTime; if (this.damageTimer >= this.damageInterval) { this.damageTimer = 0; this.enemiesHitThisInterval = []; } },
                getRadius: function () { const aoeMod = getItemModifier('AOE_RADIUS_PERCENT'); return (this.baseRadius + (this.level - 1) * 0.25) * aoeMod.percent; },
                getDamage: function () { const orbitalMod = getItemModifier('ORBITAL_EFFECT_PERCENT'); const globalDmgMod = getItemModifier('GLOBAL_DAMAGE_PERCENT'); return (this.baseDamage + (this.level - 1) * 2.5) * orbitalMod.percent * globalDmgMod.percent; },
                getRotationSpeed: function () { return this.baseRotationSpeed + (this.level - 1) * Math.PI * 0.1; },
                getShapeCount: function () { const orbitalMod = getItemModifier('ORBITAL_EFFECT_PERCENT'); return Math.floor((this.baseShapeCount + Math.floor((this.level - 1) / 2)) * orbitalMod.percent); },
                getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade,
                createMesh: function (weapon) { const meshId = weapon.id; if (persistentWeaponMeshes[meshId]) scene.remove(persistentWeaponMeshes[meshId]); const group = new THREE.Group(); const radius = weapon.getRadius(); const count = weapon.getShapeCount(); const shapeGeometry = new THREE.OctahedronGeometry(0.3, 0); const shapeMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaff, wireframe: true }); for (let i = 0; i < count; i++) { const angle = (i / count) * Math.PI * 2; const mesh = new THREE.Mesh(shapeGeometry, shapeMaterial); mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius); group.add(mesh); } group.position.copy(player.position); persistentWeaponMeshes[meshId] = group; scene.add(group); },
                updateMesh: function (weapon) { weapon.createMesh(weapon); },
                updateWeaponSystem: function (weapon, deltaTime) { const group = persistentWeaponMeshes[weapon.id]; if (!group) return; group.position.copy(player.position); group.rotation.y += weapon.getRotationSpeed() * deltaTime; if (weapon.damageTimer === 0) { const auraRadius = weapon.getRadius(); const damage = weapon.getDamage(); shapes.forEach((shape, sIndex) => { if (!weapon.enemiesHitThisInterval.includes(sIndex)) { const distance = player.position.distanceTo(shape.position); if (distance < auraRadius + (shape.radius || 0.5)) { shape.userData.health -= damage; createHitEffect(shape, 0xaaaaff, 0.1); weapon.enemiesHitThisInterval.push(sIndex); } } }); } }
            },
            PRISM_RAY: {
                id: 'PRISM_RAY', name: 'Prism Ray', icon: '', level: 0, maxLevel: 5, synergyItemId: null, tags: ['single_shot'], shortDescription: "Fires focused light.", baseFireRate: 0.8, baseDamage: 14, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { color: 0xFFFFAA, emissiveColor: 0xFFFFCC, emissiveIntensity: 0.5, damage: this.getDamage(), geometry: new THREE.CylinderGeometry(projectileRadius * 0.3, projectileRadius * 0.3, projectileRadius * 5, 6), speed: baseProjectileSpeed * 1.1, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.9, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 3.5; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            ENERGY_SIPHON: {
                id: 'ENERGY_SIPHON', name: 'Energy Siphon', icon: '', level: 0, maxLevel: 5, synergyItemId: null, tags: [], shortDescription: "Rapid fire bolts. Restores shield on enemy defeat.", baseFireRate: 0.15, baseDamage: 6, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { color: 0xff4444, emissiveColor: 0xff6666, emissiveIntensity: 0.3, damage: this.getDamage(), geometry: new THREE.SphereGeometry(projectileRadius * 0.8, 4, 4), tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.95, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 1.5; }, getShieldRestore: function () { return 1 + Math.floor((this.level - 1) / 2); }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            CUBE_CANNON: {
                id: 'CUBE_CANNON', name: 'Cube Cannon', icon: '', level: 0, maxLevel: 5, synergyItemId: 'HEAVY_CALIBRATOR', tags: ['heavy', 'aoe_on_evolve'], shortDescription: "Launches slow but powerful cubes.", baseFireRate: 1.6, baseDamage: 45, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { material: new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6, metalness: 0.2 }), damage: this.getDamage(), geometry: new THREE.BoxGeometry(projectileRadius * 2.5, projectileRadius * 2.5, projectileRadius * 2.5), speed: baseProjectileSpeed * 0.8, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.9, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 14; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            SHARD_SCATTER: {
                id: 'SHARD_SCATTER', name: 'Shard Scatter', icon: '', level: 0, maxLevel: 5, synergyItemId: 'SCATTER_MODULE', tags: ['scatter'], shortDescription: "Fires a wide spread of sharp shards.", baseFireRate: 1.0, baseDamage: 9, baseProjectileCount: 8, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { count: this.getProjectileCount(), damage: this.getDamage(), color: 0xFFFFDD, emissiveColor: 0xFFFFFF, emissiveIntensity: 0.2, geometry: new THREE.ConeGeometry(projectileRadius * 0.5, projectileRadius * 3, 4), spread: Math.PI / 4.5, speed: baseProjectileSpeed * 0.9, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.9, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 2; }, getProjectileCount: function () { return this.baseProjectileCount + (this.level - 1) * 1; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            VERTEX_VOLLEY: {
                id: 'VERTEX_VOLLEY', name: 'Vertex Volley', icon: '', level: 0, maxLevel: 5, synergyItemId: null, tags: ['single_shot'], shortDescription: "Fires precise, high-damage vertices.", baseFireRate: 0.7, baseDamage: 22, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { color: 0xC0C0C0, emissiveColor: 0xE0E0E0, emissiveIntensity: 0.3, damage: this.getDamage(), geometry: new THREE.TetrahedronGeometry(projectileRadius * 1.2, 0), speed: baseProjectileSpeed * 1.2, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.93, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 5.5; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            GEOMETRIC_FLUX: {
                id: 'GEOMETRIC_FLUX', name: 'Geometric Flux', icon: '~', level: 0, maxLevel: 5, synergyItemId: 'DURATION_COIL', tags: ['duration'], shortDescription: "Continuous stream of shifting shapes.", baseFireRate: 0.05, baseDamage: 1.5, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; const geometries = [new THREE.TetrahedronGeometry(projectileRadius * 1.5, 0), new THREE.BoxGeometry(projectileRadius * 1.5, projectileRadius * 1.5, projectileRadius * 1.5), new THREE.OctahedronGeometry(projectileRadius * 1.5, 0)]; const fluxGeometry = geometries[Math.floor(Math.random() * geometries.length)]; const durationMod = getItemModifier('DURATION_PERCENT'); fireGenericProjectile(this, { material: new THREE.MeshBasicMaterial({ color: 0x50C878, wireframe: true }), damage: this.getDamage(), speed: baseProjectileSpeed * 0.6, spread: Math.PI / 9, duration: (0.65 * durationMod.percent), geometry: fluxGeometry, onHit: (target) => { createHitEffect(target, 0x50C878, 0.3); }, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage + Math.floor((this.level - 1) / 2.5); }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            REPULSOR_WAVE: {
                id: 'REPULSOR_WAVE', name: 'Repulsor Wave', icon: '', level: 0, maxLevel: 5, synergyItemId: 'KINETIC_AMPLIFIER', tags: ['aoe', 'pulse'], shortDescription: "Short-range geometric energy blast.", baseFireRate: 0.6, baseDamage: 18, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; const aoeMod = getItemModifier('AOE_RADIUS_PERCENT'); const pulseMod = getItemModifier('PULSE_EFFECT_PERCENT'); const blastRadius = (1.6 + (this.level - 1) * 0.18) * aoeMod.percent * pulseMod.percent; const damage = this.getDamage() * pulseMod.percent; const blastColor = 0x00FFFF; shapes.forEach(shape => { const distance = player.position.distanceTo(shape.position); if (distance < blastRadius + (shape.radius || 0.5)) { shape.userData.health -= damage; createHitEffect(shape, blastColor, 0.15); } }); createTemporaryVisualEffect(player.position, blastRadius, blastColor, 0.15, true); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.9, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 4.5; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            AXIS_BOLTER: {
                id: 'AXIS_BOLTER', name: 'Axis Bolter', icon: '+', level: 0, maxLevel: 5, synergyItemId: 'FOCUS_LENS', tags: ['single_shot'], shortDescription: "Fires fast, high-damage bolts along axes.", baseFireRate: 1.2, baseDamage: 35, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { color: 0xFFF8DC, emissiveColor: 0xFFFACD, emissiveIntensity: 0.6, damage: this.getDamage(), geometry: new THREE.CylinderGeometry(projectileRadius * 0.3, projectileRadius * 0.3, projectileRadius * 6, 4), speed: baseProjectileSpeed * 1.8, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.9, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 9; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            SONIC_PRISM: {
                id: 'SONIC_PRISM', name: 'Sonic Prism', icon: '', level: 0, maxLevel: 5, synergyItemId: null, tags: ['aoe', 'pulse'], shortDescription: "Damages enemies in an area with resonant energy.", baseFireRate: 1.1, baseDamage: 9, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; const aoeMod = getItemModifier('AOE_RADIUS_PERCENT'); const pulseMod = getItemModifier('PULSE_EFFECT_PERCENT'); const blastRadius = (3.2 + (this.level - 1) * 0.33) * aoeMod.percent * pulseMod.percent; const damage = this.getDamage() * pulseMod.percent; const blastColor = 0xADD8E6; shapes.forEach(shape => { const distance = player.position.distanceTo(shape.position); if (distance < blastRadius + (shape.radius || 0.5)) { shape.userData.health -= damage; createHitEffect(shape, blastColor, 0.2); } }); createTemporaryVisualEffect(player.position, blastRadius, blastColor, 0.25, true, new THREE.IcosahedronGeometry(1, 0)); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.92, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 2.5; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            },
            SINGULARITY_LAUNCHER: {
                id: 'SINGULARITY_LAUNCHER', name: 'Singularity Launcher', icon: '', level: 0, maxLevel: 5, synergyItemId: null, tags: ['heavy'], shortDescription: "Launches slow, massive damage singularities.", baseFireRate: 2.5, baseDamage: 90, fireTimer: 0, isEvolved: false,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { material: new THREE.MeshBasicMaterial({ color: 0x111111 }), damage: this.getDamage(), geometry: new THREE.SphereGeometry(projectileRadius * 2.0, 12, 10), speed: baseProjectileSpeed * 0.5, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate * Math.pow(0.95, this.level - 1); }, getDamage: function () { return this.baseDamage + (this.level - 1) * 28; }, getUpgradeDescription: defaultGetUpgradeDescription, applyUpgrade: defaultApplyUpgrade
            }
        };
        const GENERIC_UPGRADES = {
            SHIELD_REPAIR: { id: 'SHIELD_REPAIR', name: 'Repair 30 Shield', icon: '', shortDescription: "Instantly restores 30 shield points.", getUpgradeDescription: function () { return `${this.name} ${this.icon}`; } },
            SPEED_BOOST: { id: 'SPEED_BOOST', name: 'Increase Move Speed', icon: '', shortDescription: "Permanently increases movement speed.", getUpgradeDescription: function () { return `${this.name} ${this.icon}`; } }
        };
        const ITEMS = {
            SPEED_MATRIX: { id: 'SPEED_MATRIX', name: 'Speed Matrix', icon: '', level: 0, maxLevel: 5, synergyWeaponId: null, shortDescription: "Increases movement speed.", buffType: 'MOVE_SPEED', valuePerLevel: 0.4, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            DAMAGE_CRYSTAL: { id: 'DAMAGE_CRYSTAL', name: 'Damage Crystal', icon: '', level: 0, maxLevel: 8, synergyWeaponId: null, shortDescription: "Increases all damage dealt by 5% per level.", buffType: 'GLOBAL_DAMAGE_PERCENT', valuePerLevel: 0.05, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            RATE_ACCELERATOR: { id: 'RATE_ACCELERATOR', name: 'Rate Accelerator', icon: '', level: 0, maxLevel: 8, synergyWeaponId: null, shortDescription: "Increases global fire rate by 4% per level.", buffType: 'GLOBAL_FIRERATE_PERCENT', valuePerLevel: 0.04, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            AREA_EXPANDER: { id: 'AREA_EXPANDER', name: 'Area Expander', icon: '', level: 0, maxLevel: 5, synergyWeaponId: null, shortDescription: "Increases Area of Effect size by 8% per level.", buffType: 'AOE_RADIUS_PERCENT', valuePerLevel: 0.08, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            PROJECTILE_BOOSTER: { id: 'PROJECTILE_BOOSTER', name: 'Projectile Booster', icon: '', level: 0, maxLevel: 5, synergyWeaponId: 'VECTOR_LANCE', shortDescription: "Increases projectile speed by 10% per level.", buffType: 'PROJECTILE_SPEED_PERCENT', valuePerLevel: 0.10, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            SHIELD_RECHARGER: { id: 'SHIELD_RECHARGER', name: 'Shield Recharger', icon: '', level: 0, maxLevel: 5, synergyWeaponId: null, shortDescription: "Regenerates 0.1 shield per second per level.", buffType: 'SHIELD_REGEN', valuePerLevel: 0.1, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            DATA_COLLECTOR: { id: 'DATA_COLLECTOR', name: 'Data Collector', icon: '', level: 0, maxLevel: 5, synergyWeaponId: null, shortDescription: "Increases XP pickup radius by 0.3 per level.", buffType: 'XP_PICKUP_RADIUS', valuePerLevel: 0.3, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            FOCUS_LENS: { id: 'FOCUS_LENS', name: 'Focus Lens', icon: '', level: 0, maxLevel: 5, synergyWeaponId: 'AXIS_BOLTER', shortDescription: "Increases damage of single-shot weapons by 8% per level.", buffType: 'SINGLE_SHOT_DAMAGE_PERCENT', valuePerLevel: 0.08, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            SCATTER_MODULE: { id: 'SCATTER_MODULE', name: 'Scatter Module', icon: '', level: 0, maxLevel: 3, synergyWeaponId: 'SHARD_SCATTER', shortDescription: "Adds +1 projectile to scatter weapons per level.", buffType: 'SCATTER_COUNT', valuePerLevel: 1, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            KINETIC_AMPLIFIER: { id: 'KINETIC_AMPLIFIER', name: 'Kinetic Amplifier', icon: '', level: 0, maxLevel: 5, synergyWeaponId: 'REPULSOR_WAVE', shortDescription: "Increases radius/damage of pulse weapons by 10% per level.", buffType: 'PULSE_EFFECT_PERCENT', valuePerLevel: 0.10, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            DURATION_COIL: { id: 'DURATION_COIL', name: 'Duration Coil', icon: '', level: 0, maxLevel: 5, synergyWeaponId: 'GEOMETRIC_FLUX', shortDescription: "Increases duration of effects by 15% per level.", buffType: 'DURATION_PERCENT', valuePerLevel: 0.15, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            HEAVY_CALIBRATOR: { id: 'HEAVY_CALIBRATOR', name: 'Heavy Calibrator', icon: '', level: 0, maxLevel: 5, synergyWeaponId: 'CUBE_CANNON', shortDescription: "Increases damage of heavy weapons by 10% per level.", buffType: 'HEAVY_DAMAGE_PERCENT', valuePerLevel: 0.10, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            ORBITAL_ENHANCER: { id: 'ORBITAL_ENHANCER', name: 'Orbital Enhancer', icon: '', level: 0, maxLevel: 5, synergyWeaponId: 'ORBITAL_SHIELD', shortDescription: "Increases damage/count of orbitals by 10% per level.", buffType: 'ORBITAL_EFFECT_PERCENT', valuePerLevel: 0.10, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription },
            KINETIC_ACCELERATOR: { id: 'KINETIC_ACCELERATOR', name: 'Kinetic Accelerator', icon: '', level: 0, maxLevel: 1, synergyWeaponId: 'POLY_BURST', shortDescription: "Unlocks Poly Burst evolution. (Max Lvl 1)", buffType: 'EVO_CATALYST', valuePerLevel: 1, applyUpgrade: defaultItemApplyUpgrade, getUpgradeDescription: defaultItemGetUpgradeDescription }
        };
        const EVOLVED_WEAPONS = {
            POLY_BURST: {
                id: 'POLY_BURST_EVOLVED', name: 'Nova Burst', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['aoe', 'evolved'],
                shortDescription: "Massive radial burst of high-energy shards.",
                baseFireRate: 0.45, baseDamage: 18, baseProjectileCount: 24, fireTimer: 0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; this.fireRadialShards(this); } },
                fireRadialShards: function (weapon) { // 'weapon' here is 'this' (the evolved weapon instance)
                    const count = weapon.getProjectileCount();
                    const damage = weapon.getDamage();
                    const shardGeometry = new THREE.IcosahedronGeometry(projectileRadius * 1.8, 0);
                    const shardMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x88ffff, emissiveIntensity: 0.8 });
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const velocity = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize().multiplyScalar(baseProjectileSpeed * 1.1);
                        const projectileMesh = new THREE.Mesh(shardGeometry, shardMaterial);
                        const startOffset = velocity.clone().normalize().multiplyScalar(playerRadius + projectileRadius + 0.1);
                        projectileMesh.position.copy(player.position).add(startOffset);
                        projectileMesh.position.y = player.position.y;
                        projectiles.push({
                            mesh: projectileMesh,
                            velocity: velocity,
                            damage: damage,
                            weaponId: weapon.id,
                            tags: weapon.tags, // Evolved weapon instance has its own .tags property
                            hitEnemies: new Set() // <<< --- ADD THIS LINE ---
                        });
                        scene.add(projectileMesh);
                    }
                },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getProjectileCount: function () { return this.baseProjectileCount; }, getUpgradeDescription: defaultGetUpgradeDescription
            },
            VECTOR_LANCE: {
                id: 'VECTOR_LANCE_EVOLVED', name: 'Hyper Lance', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['single_shot', 'evolved', 'piercing'],
                shortDescription: "Fires piercing hyper-velocity lances.",
                baseFireRate: 0.25, baseDamage: 35, baseProjectileCount: 3, fireTimer: 0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { count: this.baseProjectileCount, damage: this.getDamage(), color: 0xffaa00, emissiveColor: 0xffcc33, emissiveIntensity: 0.7, geometry: new THREE.CylinderGeometry(projectileRadius * 0.3, projectileRadius * 0.3, projectileRadius * 8, 4), spread: Math.PI / 30, speed: baseProjectileSpeed * 1.6, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getProjectileCount: function () { return this.baseProjectileCount; }, getUpgradeDescription: defaultGetUpgradeDescription
            },
            ORBITAL_SHIELD: {
                id: 'ORBITAL_SHIELD_EVOLVED', name: 'Vortex Shield', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['aoe', 'orbital', 'evolved'],
                shortDescription: "Rapidly spinning vortex damages and pulls enemies.",
                baseDamage: 15, baseRadius: playerRadius + 2.2, baseRotationSpeed: Math.PI * 1.6, baseShapeCount: 7, damageInterval: 0.18, damageTimer: 0, enemiesHitThisInterval: [],
                fire: function (deltaTime) { this.damageTimer += deltaTime; if (this.damageTimer >= this.damageInterval) { this.damageTimer = 0; this.enemiesHitThisInterval = []; } },
                getRadius: function () { const aoeMod = getItemModifier('AOE_RADIUS_PERCENT'); return this.baseRadius * aoeMod.percent; },
                getDamage: function () { const orbitalMod = getItemModifier('ORBITAL_EFFECT_PERCENT'); const globalDmgMod = getItemModifier('GLOBAL_DAMAGE_PERCENT'); return this.baseDamage * orbitalMod.percent * globalDmgMod.percent; },
                getRotationSpeed: function () { return this.baseRotationSpeed; },
                getShapeCount: function () { const orbitalMod = getItemModifier('ORBITAL_EFFECT_PERCENT'); return Math.floor(this.baseShapeCount * orbitalMod.percent); },
                getUpgradeDescription: defaultGetUpgradeDescription,
                createMesh: function (weapon) { const meshId = weapon.id; if (persistentWeaponMeshes[meshId]) scene.remove(persistentWeaponMeshes[meshId]); const group = new THREE.Group(); const radius = weapon.getRadius(); const count = weapon.getShapeCount(); const shapeGeometry = new THREE.TorusGeometry(0.35, 0.09, 8, 16); const shapeMaterial = new THREE.MeshBasicMaterial({ color: 0xccccff, wireframe: true }); for (let i = 0; i < count; i++) { const angle = (i / count) * Math.PI * 2; const mesh = new THREE.Mesh(shapeGeometry, shapeMaterial); mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius); mesh.rotation.x = Math.PI / 2; group.add(mesh); } group.position.copy(player.position); persistentWeaponMeshes[meshId] = group; scene.add(group); },
                updateMesh: function (weapon) { weapon.createMesh(weapon); },
                updateWeaponSystem: function (weapon, deltaTime) { const group = persistentWeaponMeshes[weapon.id]; if (!group) return; group.position.copy(player.position); group.rotation.y += weapon.getRotationSpeed() * deltaTime; const auraRadius = weapon.getRadius(); const damage = weapon.getDamage(); shapes.forEach((shape, sIndex) => { const distance = player.position.distanceTo(shape.position); if (distance < auraRadius + (shape.radius || 0.5)) { if (weapon.damageTimer === 0 && !weapon.enemiesHitThisInterval.includes(sIndex)) { shape.userData.health -= damage; createHitEffect(shape, 0xccccff, 0.1); weapon.enemiesHitThisInterval.push(sIndex); } const pullDir = new THREE.Vector3().subVectors(player.position, shape.position).normalize(); shape.position.add(pullDir.multiplyScalar(deltaTime * 2.0 * Math.max(0.1, (auraRadius - distance) / auraRadius))); } }); }
            },
            CUBE_CANNON: {
                id: 'CUBE_CANNON_EVOLVED', name: 'MegaCube Launcher', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['heavy', 'aoe', 'evolved'],
                shortDescription: "Launches huge cubes that explode on impact.",
                baseFireRate: 1.8, baseDamage: 180, fireTimer: 0, explosionRadius: 3.0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; const cubeGeom = new THREE.BoxGeometry(projectileRadius * 4.5, projectileRadius * 4.5, projectileRadius * 4.5); const cubeMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.5, metalness: 0.3 }); fireGenericProjectile(this, { damage: this.getDamage(), geometry: cubeGeom, material: cubeMat, speed: baseProjectileSpeed * 0.6, tags: this.tags, onHit: (target, projectileData) => { createBurstEffect(target.position, 40, 0xFFA500, 6, 0.5); const explosionRadius = EVOLVED_WEAPONS.CUBE_CANNON.explosionRadius * getItemModifier('AOE_RADIUS_PERCENT').percent; shapes.forEach(s => { if (s !== target && s.position.distanceTo(target.position) < explosionRadius + (s.radius || 0.5)) { s.userData.health -= projectileData.damage * 0.7; createHitEffect(s, 0xFFA500, 0.2); } }); } }); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getUpgradeDescription: defaultGetUpgradeDescription,
            },
            SHARD_SCATTER: {
                id: 'SHARD_SCATTER_EVOLVED', name: 'Crystal Storm', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['scatter', 'evolved'],
                shortDescription: "Unleashes a blinding storm of crystal shards.",
                baseFireRate: 0.7, baseDamage: 14, baseProjectileCount: 25, fireTimer: 0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { count: this.getProjectileCount(), damage: this.getDamage(), color: 0xE0FFFF, emissiveColor: 0xFFFFFF, emissiveIntensity: 0.5, geometry: new THREE.OctahedronGeometry(projectileRadius * 1.2, 0), spread: Math.PI / 3.5, speed: baseProjectileSpeed * 1.0, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getProjectileCount: function () { return this.baseProjectileCount; }, getUpgradeDescription: defaultGetUpgradeDescription,
            },
            GEOMETRIC_FLUX: {
                id: 'GEOMETRIC_FLUX_EVOLVED', name: 'Chaos Flux', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['duration', 'aoe', 'evolved'],
                shortDescription: "Spews a wide torrent of unstable chaotic shapes.",
                baseFireRate: 0.035, baseDamage: 5, baseDuration: 1.2, fireTimer: 0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; const geometries = [new THREE.TetrahedronGeometry(projectileRadius * 1.8, 0), new THREE.BoxGeometry(projectileRadius * 1.8, projectileRadius * 1.8, projectileRadius * 1.8), new THREE.OctahedronGeometry(projectileRadius * 1.8, 0), new THREE.DodecahedronGeometry(projectileRadius * 1.8, 0)]; const fluxGeometry = geometries[Math.floor(Math.random() * geometries.length)]; const durationMod = getItemModifier('DURATION_PERCENT'); const fluxColor = new THREE.Color().setHSL(Math.random(), 0.7, 0.6); fireGenericProjectile(this, { material: new THREE.MeshBasicMaterial({ color: fluxColor, wireframe: true }), damage: this.getDamage(), speed: baseProjectileSpeed * 0.7, spread: Math.PI / 5, duration: (this.baseDuration * durationMod.percent), geometry: fluxGeometry, onHit: (target) => { createHitEffect(target, fluxColor.getHex(), 0.3); }, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getUpgradeDescription: defaultGetUpgradeDescription,
            },
            REPULSOR_WAVE: {
                id: 'REPULSOR_WAVE_EVOLVED', name: 'Shockwave Pulse', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['aoe', 'pulse', 'evolved'],
                shortDescription: "Massive shockwave obliterates nearby shapes.",
                baseFireRate: 0.7, baseDamage: 60, baseRadius: 3.5, fireTimer: 0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; const aoeMod = getItemModifier('AOE_RADIUS_PERCENT'); const pulseMod = getItemModifier('PULSE_EFFECT_PERCENT'); const blastRadius = this.baseRadius * aoeMod.percent * pulseMod.percent; const damage = this.getDamage() * pulseMod.percent; const blastColor = 0x00FFFF; shapes.forEach(shape => { const distance = player.position.distanceTo(shape.position); if (distance < blastRadius + (shape.radius || 0.5)) { shape.userData.health -= damage; createHitEffect(shape, blastColor, 0.15); const pushDir = new THREE.Vector3().subVectors(shape.position, player.position).normalize(); shape.position.add(pushDir.multiplyScalar(2.0)); } }); createTemporaryVisualEffect(player.position, blastRadius, blastColor, 0.25, true, new THREE.TorusGeometry(blastRadius * 0.9, 0.1, 8, 32)); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getRadius: function () { return this.baseRadius; }, getUpgradeDescription: defaultGetUpgradeDescription,
            },
            AXIS_BOLTER: {
                id: 'AXIS_BOLTER_EVOLVED', name: 'Crucible Bolter', icon: '', isEvolved: true, level: 1, maxLevel: 1, tags: ['single_shot', 'evolved', 'piercing'],
                shortDescription: "Fires a trio of devastating, piercing energy bolts.",
                baseFireRate: 0.8, baseDamage: 70, baseProjectileCount: 3, fireTimer: 0,
                fire: function (deltaTime) { const fireRateMod = getItemModifier('GLOBAL_FIRERATE_PERCENT'); this.fireTimer += deltaTime; if (this.fireTimer >= this.getFireRate() / fireRateMod.percent) { this.fireTimer = 0; fireGenericProjectile(this, { count: this.baseProjectileCount, color: 0xFFFFE0, emissiveColor: 0xFFFFF0, emissiveIntensity: 0.7, damage: this.getDamage(), geometry: new THREE.CylinderGeometry(projectileRadius * 0.4, projectileRadius * 0.4, projectileRadius * 7, 6), speed: baseProjectileSpeed * 2.0, spread: Math.PI / 20, tags: this.tags }); } },
                getFireRate: function () { return this.baseFireRate; }, getDamage: function () { return this.baseDamage; }, getProjectileCount: function () { return this.baseProjectileCount; }, getUpgradeDescription: defaultGetUpgradeDescription,
            },
        };

        const ENEMY_TYPES = {
            // --- COMMON HORDE ENEMIES ---
            CUBE_CRUSHER: {
                name: 'Cube Crusher', icon: '', geometryType: 'Box', size: [0.8, 0.8, 0.8], color: 0xcc3333,
                speed: 1.3, healthMultiplier: 1.5, xpMultiplier: 0.7, dropsCache: false, // Was 0.7, now 1.8
                specialAbility: null, damageMultiplier: 0.7, cost: 1
            },
            TETRA_SWARMER: { // These are fast and numerous, should still be weak, maybe 1-2 shots
                name: 'Tetra Swarmer', icon: 'tetrahedral', geometryType: 'Tetrahedron', size: [0.4, 0], color: 0x9A1F1F,
                speed: 3.6, healthMultiplier: 0.6, xpMultiplier: 0.4, dropsCache: false, // Was 0.35, now 0.8
                specialAbility: null, damageMultiplier: 0.6, cost: 0.5
            },

            // --- SLIGHTLY TOUGHER / MORE NUMEROUS HORDE ---
            ICOSAHEDRON_INVADER: {
                name: 'Icosahedron Invader', icon: '', geometryType: 'Icosahedron', size: [0.6, 0], color: 0x4B5320,
                speed: 1.2, healthMultiplier: 1.5, xpMultiplier: 0.8, dropsCache: false, // Was 0.9, now 2.0
                specialAbility: 'distort', distortCooldown: 12, distortTimer: 6 + Math.random() * 6, damageMultiplier: 0.8, cost: 1.5
            },
            SPHERE_SPLITTER: { // Initial sphere
                name: 'Sphere Splitter', icon: '', geometryType: 'Sphere', size: [0.5, 12, 8], color: 0x98FB98,
                speed: 1.0, healthMultiplier: 1.2, xpMultiplier: 0.6, dropsCache: false, // Was 0.6, now 1.5
                specialAbility: 'split', generation: 1, damageMultiplier: 0.4, cost: 1.2
            },
            CYLINDER_CORRUPTER: {
                name: 'Cylinder Corrupter', icon: '', geometryType: 'Cylinder', size: [0.3, 0.3, 1.0, 8], color: 0x4F4F4F,
                speed: 2.0, healthMultiplier: 1.4, xpMultiplier: 0.9, dropsCache: false, // Was 0.8, now 1.8
                specialAbility: 'corrupt_touch', damageMultiplier: 0.5, cost: 2
            },

            // --- SPECIAL ABILITY / MID-TIER ENEMIES ---
            // These can remain relatively similar as their threat comes from abilities more than pure HP
            PRISM_DASHER: {
                name: 'Prism Dasher', icon: '', geometryType: 'Cylinder', size: [0.35, 1.5, 0.35, 6], color: 0xB0C4DE,
                speed: 0, healthMultiplier: 1.7, xpMultiplier: 1.2, dropsCache: false, // Was 1.2
                specialAbility: 'dash', dashSpeed: 7.0, dashDuration: 0.45, dashCooldown: 2.8, dashTimer: 1.5 + Math.random(), isDashing: false, damageMultiplier: 1.2, cost: 3
            },
            CONE_CASTER: {
                name: 'Cone Caster', icon: '', geometryType: 'Cone', size: [0.45, 1.3, 8], color: 0xB8860B,
                speed: 1.0, healthMultiplier: 2.2, xpMultiplier: 1.3, dropsCache: false, // Was 1.4
                specialAbility: 'launch_shard', shardCooldown: 4.5, shardTimer: Math.random() * 4.5, deathBurstRadius: 2.0, deathBurstDamage: 10, damageMultiplier: 0.9, cost: 3.5
            },
            DODECAHEDRON_DRIFTER: {
                name: 'Dodecahedron Drifter', icon: '', geometryType: 'Dodecahedron', size: [0.6, 0], color: 0x181818,
                speed: 1.7, healthMultiplier: 2.5, xpMultiplier: 1.5, dropsCache: false, // Was 1.6
                specialAbility: 'phase_shift', shiftCooldown: 5.5, shiftTimer: Math.random() * 5.5, damageMultiplier: 1.0, cost: 4
            },

            // --- ELITE / TANK ENEMIES ---
            // These should definitely take more hits
            PYRAMID_PIERCER: { // Cache Carrier
                name: 'Pyramid Piercer', icon: '', geometryType: 'Cone', size: [0.7, 1.8, 4], color: 0xcc6600,
                speed: 0.9, healthMultiplier: 8.0, xpMultiplier: 2.8, dropsCache: true, // Was 3.5, now 5.0 (significant increase)
                specialAbility: null, damageMultiplier: 1.2, cost: 7
            },
            OCTAHEDRON_OBSTACLE: { // True Tank
                name: 'Octahedron Obstacle', icon: '', geometryType: 'Octahedron', size: [0.8, 0], color: 0x696969,
                speed: 0.5, healthMultiplier: 8.0, xpMultiplier: 4.0, dropsCache: false, // Was 6.0, now 8.0 (very tanky)
                specialAbility: 'tough', damageMultiplier: 1.0, cost: 12
            },
            BOSS_OCTA_PRIME: {
                name: 'Octa Prime',
                icon: '',
                geometryType: 'Octahedron',
                size: [3.0, 0],
                color: 0xFF1493,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0x8B008B,
                emissiveIntensity: 0.6,
                flatShading: false,
                speed: 6.4,             // Base speed (can be modified by abilities)
                healthMultiplier: 250.0,
                xpMultiplier: 100.0,
                dropsCache: true,
                currencyDrop: 500 + Math.floor(Math.random() * 251),
                damageMultiplier: 4.5,
                cost: 500,
                isBoss: true,

                // --- Abilities Data ---
                specialAbility: 'multi_attack',
                attackPatterns: ['PULSE', 'RAPID_FIRE', 'DASH_SLAM', 'SUMMON'], // Possible patterns
                currentAttackPattern: 'PULSE', // Start with Pulse
                attackState: 'MOVING', // States: MOVING, CHARGING_PULSE, PULSING, CHARGING_RAPID, FIRING_RAPID, CHARGING_DASH, DASHING, SLAMMING, SUMMONING
                attackStateTimer: 0,      // Timer specific to the current state of an attack
                attackCooldown: 4.0,      // Cooldown between *different* attack sequences (was 3.5, increased slightly)
                attackCooldownTimer: 4.0, // Timer for the main cooldown

                // -- Pattern Specific Data --
                // Rapid Fire
                rapidFireBursts: 0,       // Bursts left in current rapid fire sequence
                rapidFireBurstTimer: 0,   // Timer between shots within a burst
                rapidFireTargetPos: null, // Target position for the burst
                // Dash Slam
                dashChargeTime: 1.0,
                dashSpeedMultiplier: 4.0,
                dashDuration: 0.6,
                slamRadius: 5.0,
                slamDamage: 50,           // Example damage for the slam AOE
                // Pulse
                pulseChargeTime: 1.2,
                pulseRadius: 8.0,
                pulseDamage: 35,          // Example damage for the pulse AOE
                pulseColor: 0xFF69B4,     // Hot Pink for pulse effect
                // Summon
                summonChargeTime: 1.5,
                summonCount: 3,           // Number of minions to summon
                summonType: 'CYLINDER_CORRUPTER' // Type of minion
            }

        };

        // --- Initialization ---
        function init() {
            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

            loadGameData(); // Load persistent data first
            initializeAudio(); // Prepare AudioContext

            scene = new THREE.Scene();
            // ... (rest of scene, camera, renderer, lights, ground, grid setup as before) ...
            scene.background = new THREE.Color(0x111827);
            scene.fog = new THREE.Fog(0x111827, 35, 90);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const initialHeight = isTouchDevice ? 12 : 15; // Lower initial camera height for mobile
            const initialZoom = isTouchDevice ? 8.5 : 18; // Closer initial zoom for mobile
            camera.position.set(0, initialHeight, initialZoom);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            const hemiLight = new THREE.HemisphereLight(0x88aaff, 0x446644, 0.7); scene.add(hemiLight);
            const ambientLight = new THREE.AmbientLight(0x606080, 0.5); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(15, 20, 18); directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 80;
            directionalLight.shadow.camera.left = -WORLD_BOUNDARY - 5; directionalLight.shadow.camera.right = WORLD_BOUNDARY + 5;
            directionalLight.shadow.camera.top = WORLD_BOUNDARY + 5; directionalLight.shadow.camera.bottom = -WORLD_BOUNDARY - 5;
            directionalLight.shadow.bias = -0.001; scene.add(directionalLight);
            const playerLight = new THREE.PointLight(0xaaaaff, 0.4, 20); playerLight.position.set(0, 3, 0); scene.add(playerLight);
            const groundGeometry = new THREE.PlaneGeometry(WORLD_BOUNDARY * 2.2, WORLD_BOUNDARY * 2.2);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.8, metalness: 0.1 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);
            gridHelper = new THREE.GridHelper(WORLD_BOUNDARY * 2.2, Math.floor(WORLD_BOUNDARY * 2.2 / 2), 0x4b5563, 0x374151);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0.01; scene.add(gridHelper);

            createPlayer();
            populateLevelList();
            setupTouchControls();
            updateJoystickVisibility();
            createBackgroundPattern();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('mousemove', onMouseMove, false);
            if (fullscreenButton) {
                fullscreenButton.addEventListener('click', toggleFullScreen);
            }

            animate();
        }

        function populateLevelList() {
            console.log("populateLevelList called. levelListElement:", levelListElement); // Check if element exists
            if (!levelListElement) {
                console.error("levelListElement is NULL in populateLevelList!");
                return;
            }

            levelListElement.innerHTML = ''; // Clear previous (good practice)
            console.log("gameLevels array:", gameLevels); // Check the array data

            if (gameLevels && gameLevels.length > 0) {
                gameLevels.forEach(level => {
                    console.log("Processing level:", level.name, "Unlocked:", level.unlocked);
                    const button = document.createElement('button');
                    button.classList.add('level-button');
                    button.textContent = `${level.name} - ${level.description}`;

                    if (level.unlocked) {
                        button.onclick = () => {
                            console.log("Level button clicked for:", level.name);
                            startGame(level.id);
                        };
                    } else {
                        button.disabled = true;
                        button.textContent += " (Locked)";
                    }
                    try {
                        levelListElement.appendChild(button);
                        console.log("Appended button for:", level.name);
                    } catch (e) {
                        console.error("Error appending button for " + level.name + ":", e);
                    }
                });
            } else {
                console.warn("gameLevels array is empty or undefined.");
            }
            console.log("populateLevelList finished. levelListElement children count:", levelListElement.children.length);
        }

        // --- Game Flow Functions ---
        function clearDynamicSceneObjects() {
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const child = scene.children[i];
                if (child !== player && child !== ground && !(child instanceof THREE.Light) && !(child instanceof THREE.Camera) && child !== gridHelper && !staticLevelObjects.includes(child) && child !== backgroundPattern) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) { if (Array.isArray(child.material)) { child.material.forEach(material => { if (material && material.dispose) material.dispose(); }); } else { if (child.material.dispose) child.material.dispose(); } }
                    scene.remove(child);
                }
            }
            staticLevelObjects.forEach(obj => { if (obj.parent) scene.remove(obj); if (obj.geometry) obj.geometry.dispose(); if (obj.material && obj.material.dispose) obj.material.dispose(); });
            staticLevelObjects.length = 0;

            shapes.length = 0; projectiles.length = 0; dataFragments.length = 0; hitEffects.length = 0;
            geometricCaches.length = 0; repairNodes.length = 0; energyCores.length = 0; particles.length = 0;

            megaDataFragments.forEach(frag => {
                if (frag.mesh && frag.mesh.parent) scene.remove(frag.mesh);
                if (frag.mesh && frag.mesh.geometry) frag.mesh.geometry.dispose();
                if (frag.mesh && frag.mesh.material) frag.mesh.material.dispose();
            });
            megaDataFragments.length = 0;
            accumulatedOffScreenXP = 0; // Reset accumulated XP

            Object.values(persistentWeaponMeshes).forEach(mesh => { if (mesh.parent) scene.remove(mesh); });
            persistentWeaponMeshes = {};
        }

        function startGame(levelId) {
            // --- Initialize Audio Context on first interaction ---
            initializeAudio();

            currentLevelId = levelId;
            const selectedLevelData = gameLevels.find(l => l.id === levelId);
            if (!selectedLevelData || !selectedLevelData.unlocked) return;

            // --- Apply Meta Upgrades ---
            applyMetaUpgradesToGame(); // Sets MAX_PLAYER_SHIELD, baseDamageMultiplier etc.

            // --- Reset Run-Specific Stats ---
            playerShield = MAX_PLAYER_SHIELD; // Start with potentially upgraded max shield
            score = 0; playerLevel = 1; currentXP = 0; xpToNextLevel = 60;
            playerWeapons.length = 0; playerItems.length = 0;
            gameTime = 0;
            playerCorruptionTimer = 0; corruptionEffectTimer = 0; shieldRegenTimer = 0;
            isBossWave = false; // Reset boss flag
            nextBossTime = 540; // Reset boss timer (5 minutes)

            clearDynamicSceneObjects();

            Object.values(WEAPONS).forEach(w => { w.level = 0; w.isEvolved = false; w.fireTimer = 0; w.damageTimer = 0; w.enemiesHitThisInterval = []; });
            Object.values(ITEMS).forEach(i => { i.level = 0; });

            if (player) { player.position.set(0, playerHeight / 2, 0); } else { createPlayer(); }
            if (selectedLevelData.mapSetup) selectedLevelData.mapSetup();
            if (WEAPONS.VECTOR_LANCE) WEAPONS.VECTOR_LANCE.applyUpgrade();

            recalculatePlayerStats(); // Applies item effects on top of meta upgrades
            shapeSpawnTimer = 0; shapeSpawnInterval = baseShapeSpawnInterval;
            eliteSpawnTimer = 35; pickupSpawnTimer = 5;

            updateUI(); updateWeaponUI(); updateItemUI();

            // --- Hide Menus, Show Game UI ---
            mainMenuElement.style.display = 'none'; levelSelectMenuElement.style.display = 'none';
            upgradeMenuElement.style.display = 'none'; // Hide upgrade menu
            pauseMenuElement.style.display = 'none'; settingsMenuElement.style.display = 'none';
            gameOverElement.style.display = 'none'; levelUpScreenElement.style.display = 'none';
            cacheRewardPopupElement.style.display = 'none'; winScreenElement.style.display = 'none';
            evolutionBookMenuElement.style.display = 'none';
            gameUiElement.style.display = 'block';

            currentGameState = GameState.Playing; isPaused = false;
            updateJoystickVisibility();
            if (!clock.running) clock.start();
        }

        function showLevelSelect() {
            console.log("showLevelSelect called");
            console.log("mainMenuElement display before:", mainMenuElement.style.display);
            mainMenuElement.style.display = 'none';
            console.log("mainMenuElement display after:", mainMenuElement.style.display);

            console.log("levelSelectMenuElement display before:", levelSelectMenuElement.style.display);
            levelSelectMenuElement.style.display = 'flex'; // Or 'block'
            console.log("levelSelectMenuElement display after:", levelSelectMenuElement.style.display);
            console.log("levelSelectMenuElement innerHTML:", levelSelectMenuElement.innerHTML); // Check if content is there
            console.log("levelListElement children count:", levelListElement.children.length); // Check if buttons were added

            currentGameState = GameState.LevelSelect;
            updateJoystickVisibility();
        }
        function hideLevelSelect() { /* ... calls updateJoystickVisibility ... */
            levelSelectMenuElement.style.display = 'none';
            mainMenuElement.style.display = 'flex';
            currentGameState = GameState.MainMenu;
            updateJoystickVisibility();
        }
        function pauseGame() { if (currentGameState === GameState.Playing) { previousGameState = currentGameState; currentGameState = GameState.Paused; isPaused = true; pauseMenuElement.style.display = 'flex'; updateJoystickVisibility(); } }
        function resumeGame() { if (currentGameState === GameState.Paused) { currentGameState = GameState.Playing; isPaused = false; pauseMenuElement.style.display = 'none'; updateJoystickVisibility(); } }
        function showSettings(originStateKey) { /* ... calls updateJoystickVisibility ... */
            previousGameState = GameState[originStateKey];
            currentGameState = GameState.Settings; isPaused = true;
            settingsMenuElement.style.display = 'flex';
            if (previousGameState === GameState.MainMenu) mainMenuElement.style.display = 'none';
            if (previousGameState === GameState.Paused) pauseMenuElement.style.display = 'none';
            updateJoystickVisibility();
        }
        function hideSettings() { /* ... calls updateJoystickVisibility ... */
            settingsMenuElement.style.display = 'none';
            currentGameState = previousGameState;
            isPaused = (currentGameState !== GameState.Playing && currentGameState !== GameState.MainMenu);
            if (currentGameState === GameState.MainMenu) mainMenuElement.style.display = 'flex';
            if (currentGameState === GameState.Paused) pauseMenuElement.style.display = 'flex';
            updateJoystickVisibility();
        }
        function quitToMainMenu() { /* ... calls updateJoystickVisibility ... */
            currentGameState = GameState.MainMenu; isPaused = true;
            gameUiElement.style.display = 'none'; pauseMenuElement.style.display = 'none';
            gameOverElement.style.display = 'none'; settingsMenuElement.style.display = 'none';
            levelUpScreenElement.style.display = 'none'; cacheRewardPopupElement.style.display = 'none';
            winScreenElement.style.display = 'none'; evolutionBookMenuElement.style.display = 'none';
            levelSelectMenuElement.style.display = 'none';
            mainMenuElement.style.display = 'flex';
            updateJoystickVisibility();
            clearDynamicSceneObjects();
        }
        function showEvolutionBook() { /* ... calls updateJoystickVisibility ... */
            if (currentGameState !== GameState.Paused) return;
            previousGameState = GameState.Paused;
            currentGameState = GameState.EvolutionBook;
            pauseMenuElement.style.display = 'none';
            evolutionBookMenuElement.style.display = 'flex';
            populateEvolutionBook();
            updateJoystickVisibility();
        }
        function hideEvolutionBook() { /* ... calls updateJoystickVisibility ... */
            if (currentGameState !== GameState.EvolutionBook) return;
            evolutionBookMenuElement.style.display = 'none';
            pauseMenuElement.style.display = 'flex';
            currentGameState = GameState.Paused;
            updateJoystickVisibility();
        }


        // --- Helper: Calculate Stat Modifier from Items --- // (Included for context, assumed to be already present and correct)
        function getItemModifier(buffType) {
            let modifier = { percent: 1.0, flat: 0.0, count: 0 };
            playerItems.forEach(item => {
                if (item.level > 0 && item.buffType === buffType) {
                    const value = item.level * item.valuePerLevel;
                    if (buffType.includes('_PERCENT')) {
                        modifier.percent += value;
                    } else if (buffType.includes('_COUNT')) {
                        modifier.count += Math.floor(value);
                    } else {
                        modifier.flat += value;
                    }
                }
            });
            return modifier;
        }

        // --- Evolution Book Population ---
        function populateEvolutionBook() {
            evolutionListElement.innerHTML = ''; // Clear existing entries
            let evolutionsFound = false;
            Object.values(WEAPONS).forEach(weapon => {
                if (weapon.synergyItemId && EVOLVED_WEAPONS[weapon.id]) {
                    const synergyItem = ITEMS[weapon.synergyItemId];
                    const evolvedWeapon = EVOLVED_WEAPONS[weapon.id];
                    if (synergyItem && evolvedWeapon) {
                        evolutionsFound = true;
                        const entryDiv = document.createElement('div');
                        entryDiv.classList.add('evolution-entry');
                        entryDiv.innerHTML = `
        <span class="weapon-name">${weapon.name} ${weapon.icon} (Lvl ${weapon.maxLevel})</span> +
        <span class="item-name">${synergyItem.name} ${synergyItem.icon} (Any Lvl > 0)</span><br>
        => <strong class="evolved-name">${evolvedWeapon.name} ${evolvedWeapon.icon}</strong>
        <p style="font-size:0.9em; color: #ccc; margin-top: 5px;"><em>${evolvedWeapon.shortDescription}</em></p>
        `;
                        evolutionListElement.appendChild(entryDiv);
                    }
                }
            });

            if (!evolutionsFound) {
                evolutionListElement.innerHTML = '<p>No evolutions discovered or defined yet.</p>';
            }
        }

        function selectEnemyTypeForHorde(currentBudget) {
            const availableTypes = [];

            // Define time thresholds for introducing enemy types - ADJUSTED FOR 10 MINUTE GAME
            const timeThresholds = {
                // Game time in seconds
                TETRA_SWARMER: 20,        // Available after 20 seconds
                ICOSAHEDRON_INVADER: 75,  // Available after 1 min 15 sec
                SPHERE_SPLITTER: 150,     // Available after 2 min 30 sec (If testing early, adjust this)
                PRISM_DASHER: 240,        // Available after 4 minutes
                CYLINDER_CORRUPTER: 330,  // Available after 5 min 30 sec
                CONE_CASTER: 420,         // Available after 7 minutes
                DODECAHEDRON_DRIFTER: 510 // Available after 8 min 30 sec
            };

            // Always consider the base enemy (Cube Crusher) if budget allows.
            if (currentBudget >= ENEMY_TYPES.CUBE_CRUSHER.cost) {
                availableTypes.push('CUBE_CRUSHER');
            }

            // Add other types based on time elapsed and budget
            for (const typeId in timeThresholds) {
                if (gameTime >= timeThresholds[typeId]) {
                    const typeData = ENEMY_TYPES[typeId];
                    if (typeData && currentBudget >= typeData.cost) {
                        if (!availableTypes.includes(typeId)) {
                            availableTypes.push(typeId);
                        }
                    }
                }
            }

            if (availableTypes.length === 0) {
                if (gameTime >= timeThresholds.TETRA_SWARMER && currentBudget >= ENEMY_TYPES.TETRA_SWARMER.cost) {
                    return 'TETRA_SWARMER';
                }
                if (currentBudget >= ENEMY_TYPES.CUBE_CRUSHER.cost) {
                    return 'CUBE_CRUSHER';
                }
                return null;
            }

            // Weighted Selection Logic
            // Shorter game means timeWeightFactor ramps up faster relative to game duration
            const timeWeightFactor = Math.min(1.0, gameTime / (10 * 60 * 0.75)); // Max out bias by 7.5 mins (0.75 of 10 mins)

            const weights = availableTypes.map(typeId => {
                const cost = ENEMY_TYPES[typeId].cost;
                let weight = Math.max(0.1, 1 / (cost * cost)); // Base weight favors cheap
                if (cost > 1.5) { // Apply time bias more readily for non-cheapest enemies
                    weight *= (1 + timeWeightFactor * (cost / 2.5)); // Stronger bias for cost over time
                }
                // Reduce weight for very high cost units if other options exist and budget is tight for it
                if (cost > currentBudget * 0.65 && availableTypes.length > 1 && cost > (ENEMY_TYPES.CUBE_CRUSHER.cost + 0.5)) {
                    weight *= 0.3;
                }
                return weight;
            });

            const totalWeight = weights.reduce((sum, w) => sum + w, 0);

            if (totalWeight <= 0.01) {
                if (availableTypes.length > 0) return availableTypes[Math.floor(Math.random() * availableTypes.length)];
                return ENEMY_TYPES.CUBE_CRUSHER.cost <= currentBudget ? 'CUBE_CRUSHER' : null;
            }

            let random = Math.random() * totalWeight;
            for (let i = 0; i < availableTypes.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return availableTypes[i];
                }
            }
            return availableTypes.length > 0 ? availableTypes[availableTypes.length - 1] : null;
        }

        function handleSpawning(deltaTime) {
            if (isBossWave) {
                handleBossWave(deltaTime);
            } else {
                handleBossSpawnTrigger();
                handleRegularSpawning(deltaTime);
            }
        }

        function handleBossWave(deltaTime) {
            pickupSpawnTimer += deltaTime;
            const bossExists = shapes.some(s => s.userData?.type === 'BOSS_OCTA_PRIME' && s.parent);

            // Retry spawning the boss until successful.
            if (!bossExists) {
                console.warn("Boss not found, retrying spawn...");
                spawnEnemyByType('BOSS_OCTA_PRIME');
            }

            // Handle pickups during the boss wave.
            const adjustedPickupInterval = Math.max(5.0, pickupSpawnInterval * 1.5);
            updatePickupSpawnTimer(deltaTime, adjustedPickupInterval, 0.5, 0.7);

            // Check if the boss was defeated.
            if (!bossExists && gameTime >= nextBossTime + 10) {
                winGame();
            }
        }

        function handleBossSpawnTrigger() {
            const bossStartTime = 540; // 9 minutes
            if (gameTime >= bossStartTime && !isBossWave) {
                console.log("BOSS WAVE STARTING! Spawning Final Boss...");
                isBossWave = true;
                spawnEnemyByType('BOSS_OCTA_PRIME');
            }
        }

        function handleRegularSpawning(deltaTime) {
            const timeFactor = Math.min(1, gameTime / (60 * 5));
            shapeSpawnInterval = Math.max(0.15, baseShapeSpawnInterval - (gameTime * 0.0035));
            updateSpawnTimer(deltaTime, shapeSpawnInterval, spawnShapeWave);

            const eliteBaseInterval = 25;
            const currentEliteInterval = Math.max(12, eliteBaseInterval - playerLevel * 0.5 - timeFactor * 5);
            updateEliteSpawnTimer(deltaTime, currentEliteInterval);

            const currentPickupInterval = Math.max(2.5, pickupSpawnInterval - gameTime * 0.020);
            updatePickupSpawnTimer(deltaTime, currentPickupInterval, 0.6, 0.98);
        }

        function updatePickupSpawnTimer(deltaTime, interval, repairNodeChance, energyCoreChance) {
            pickupSpawnTimer += deltaTime;
            if (pickupSpawnTimer > interval) {
                pickupSpawnTimer = 0;
                const rand = Math.random();
                if (rand < repairNodeChance) spawnRepairNode();
                else if (rand < energyCoreChance) spawnEnergyCore();
            }
        }

        function updateSpawnTimer(deltaTime, interval, spawnCallback) {
            shapeSpawnTimer += deltaTime;
            if (shapeSpawnTimer > interval) {
                shapeSpawnTimer = 0;
                spawnCallback();
            }
        }

        function updateEliteSpawnTimer(deltaTime, interval) {
            eliteSpawnTimer += deltaTime;
            if (eliteSpawnTimer > interval) {
                eliteSpawnTimer = 0;

                if (gameTime > 90 && Math.random() < Math.min(0.6, 0.10 + playerLevel * 0.02 + Math.min(1, gameTime / 300) * 0.12)) {
                    spawnEnemyByType('PYRAMID_PIERCER');
                }
                if (gameTime > 240 && Math.random() < Math.min(0.45, 0.07 + playerLevel * 0.015 + Math.min(1, gameTime / 300) * 0.10)) {
                    spawnEnemyByType('OCTAHEDRON_OBSTACLE');
                }
            }
        }

        function spawnShapeWave() {
            let spawnPointsBudget = Math.min(8 + Math.floor(gameTime / 10) + playerLevel * 1.8, 55);
            const maxEnemies = gameTime < 300 ? 15 : 22;

            let spawnedThisInterval = 0;
            while (spawnPointsBudget > 0 && spawnedThisInterval < maxEnemies) {
                const enemyTypeId = selectEnemyTypeForHorde(spawnPointsBudget);
                if (!enemyTypeId) break;

                const typeData = ENEMY_TYPES[enemyTypeId];
                if (typeData && typeData.cost <= spawnPointsBudget) {
                    spawnEnemyByType(enemyTypeId);
                    spawnPointsBudget -= typeData.cost;
                    spawnedThisInterval++;
                } else if (typeData && spawnPointsBudget < typeData.cost && spawnPointsBudget > 0.3 && spawnedThisInterval === 0) {
                    spawnEnemyByType(enemyTypeId);
                    spawnPointsBudget = 0;
                    spawnedThisInterval++;
                } else {
                    break;
                }
            }
        }

        function handleXPOrbConsolidation(deltaTime) {
            if (accumulatedOffScreenXP >= MEGA_XP_THRESHOLD) {
                spawnMegaDataFragment(accumulatedOffScreenXP);
                accumulatedOffScreenXP = 0;
            }
        }

        // --- Update Function for Playing State ---
        function updatePlaying(deltaTime) {
            if (!player || currentGameState !== GameState.Playing || isPaused) return; // Added isPaused check

            // Shield Regeneration
            const shieldRegenMod = getItemModifier('SHIELD_REGEN');
            if (shieldRegenMod.flat > 0) {
                shieldRegenTimer += deltaTime;
                if (shieldRegenTimer >= 1.0) { // Regenerate per second
                    playerShield = Math.min(MAX_PLAYER_SHIELD, playerShield + shieldRegenMod.flat);
                    shieldRegenTimer -= 1.0;
                }
            }

            // Corruption Effect
            if (corruptionEffectTimer > 0) {
                corruptionEffectTimer -= deltaTime;
                playerCorruptionTimer += deltaTime;
                if (playerCorruptionTimer >= CORRUPTION_INTERVAL) {
                    playerCorruptionTimer = 0;
                    playerShield -= CORRUPTION_DAMAGE;
                    createHitEffect(player, 0x00ff00, 0.1); // Green hit for corruption (can be changed)
                    if (playerShield <= 0) {
                        gameOver();
                        return;
                    }
                }
            } else {
                playerCorruptionTimer = 0; // Reset timer if effect wears off
            }

            updatePlayer(deltaTime);
            updateCamera();
            updateAimTarget();
            updateShapes(deltaTime);
            updateProjectiles(deltaTime);
            updateWeapons(deltaTime);
            updateDataFragments(deltaTime);
            updateMegaDataFragments(deltaTime); // <<< --- ADD THIS LINE ---
            updateHitEffects(deltaTime);
            updatePickups(deltaTime);
            updateParticles(deltaTime);
            handleSpawning(deltaTime);
            handleXPOrbConsolidation(deltaTime); // <<< --- ADD THIS LINE ---
            checkCollisions();
            updateUI(); // Keep UI updated last
        }

        // --- Core Update Functions ---
        function createPlayer() {
            const playerGeometry = new THREE.IcosahedronGeometry(playerRadius, 1); // A more complex shape for the player
            const playerMaterial = new THREE.MeshStandardMaterial({
                color: 0x44AAFF,
                emissive: 0x2266aa, // Slight glow
                emissiveIntensity: 0.4,
                roughness: 0.4,
                metalness: 0.3,
                flatShading: false // Smoother look
            });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.y = playerHeight / 2; // Ensure player is on the ground plane correctly
            player.castShadow = true;
            scene.add(player);
        }

        function updatePlayer(deltaTime) {
            if (!player) return;

            const moveSpeed = playerSpeed * deltaTime;
            const moveVector = new THREE.Vector3();

            if (joystickActive && isTouchDevice) { // Movement Joystick
                const dx = parseFloat(joystickKnob.style.left) + knobRadius - joystickRadius;
                const dy = parseFloat(joystickKnob.style.top) + knobRadius - joystickRadius;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 5) { // Deadzone
                    const maxKnobTravel = joystickRadius - knobRadius;
                    moveVector.x = dx / maxKnobTravel;
                    moveVector.z = dy / maxKnobTravel; // Joystick Y maps to game Z (screen down is often +Y)
                }
            } else { // Keyboard fallback
                if (moveState.forward) moveVector.z -= 1;
                if (moveState.backward) moveVector.z += 1;
                if (moveState.left) moveVector.x -= 1;
                if (moveState.right) moveVector.x += 1;
            }

            if (moveVector.lengthSq() > 0) {
                moveVector.normalize().multiplyScalar(moveSpeed);
                player.position.add(moveVector);
            }

            // Obstacle Collision for Player
            staticLevelObjects.forEach(obstacle => {
                if (obstacle.userData.isObstacle) {
                    const distance = player.position.distanceTo(obstacle.position);
                    const collisionThreshold = playerRadius + (obstacle.userData.obstacleRadius || 0.5);
                    if (distance < collisionThreshold) {
                        const overlap = collisionThreshold - distance;
                        const pushDirection = new THREE.Vector3().subVectors(player.position, obstacle.position).normalize();
                        pushDirection.y = 0; // Keep push on XZ plane
                        player.position.add(pushDirection.multiplyScalar(overlap * 1.01)); // Push out slightly more than overlap
                    }
                }
            });

            // World boundary checks
            player.position.x = Math.max(-WORLD_BOUNDARY + playerRadius, Math.min(WORLD_BOUNDARY - playerRadius, player.position.x));
            player.position.z = Math.max(-WORLD_BOUNDARY + playerRadius, Math.min(WORLD_BOUNDARY - playerRadius, player.position.z));

            player.position.y = playerHeight / 2; // Keep player on ground plane correctly

            // Subtle player rotation for visual feedback
            player.rotation.y += deltaTime * 0.15 * (moveVector.x); // Rotate based on sideways movement
            player.rotation.x += deltaTime * 0.1 * (moveVector.z); // Tilt based on forward/backward

            // Keep persistent weapon meshes (like orbitals) synced
            Object.values(persistentWeaponMeshes).forEach(mesh => mesh.position.copy(player.position));
        }


        // --- Game Loop ---
        let lastFrameTime = 0;
        const targetFrameRate = 60; // Target 60 FPS
        const frameInterval = 1000 / targetFrameRate; // Time between frames in ms

        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            // Frame rate limiting
            const elapsed = currentTime - lastFrameTime;
            if (elapsed < frameInterval) {
                return; // Skip this frame to maintain target frame rate
            }

            // Calculate delta time based on actual elapsed time
            // Use a maximum delta time to prevent huge jumps after tab switch/sleep
            const deltaTime = Math.min(0.1, clock.getDelta());

            // Update last frame time, accounting for the remainder to avoid drift
            lastFrameTime = currentTime - (elapsed % frameInterval);

            // Update frustum for visibility checks
            updateFrustum();

            // Game state updates
            if (currentGameState === GameState.Playing && !isPaused) { 
                gameTime += deltaTime; 
                updatePlaying(deltaTime); 
            }

            // Background pattern update
            if (backgroundPattern) {
                backgroundPattern.material.uniforms.time.value = clock.getElapsedTime() * 0.05;
            }

            // Apply frustum culling to scene objects
            applyFrustumCulling();

            // Rendering
            if (renderer && scene && camera) { 
                try { 
                    renderer.render(scene, camera); 
                } catch (renderError) { 
                    console.error("Render Error:", renderError); 
                } 
            }
        }

        // Apply frustum culling to scene objects
        function applyFrustumCulling() {
            // Skip if camera or player not ready
            if (!camera || !player) return;

            // Get player position for distance checks
            const playerPos = player.position;

            // Apply to shapes (enemies)
            shapes.forEach(shape => {
                if (shape && shape.parent) {
                    // Always show shapes close to player regardless of frustum
                    const distToPlayer = shape.position.distanceToSquared(playerPos);
                    const isClose = distToPlayer < 400; // 20 units squared

                    // Set visibility based on frustum or proximity
                    shape.visible = isClose || isVisible(shape, shape.radius || 1);
                }
            });

            // Apply to projectiles
            projectiles.forEach(projectile => {
                if (projectile && projectile.mesh && projectile.mesh.parent) {
                    projectile.mesh.visible = isVisible(projectile.mesh, projectileRadius);
                }
            });

            // Apply to particles
            particles.forEach(particle => {
                if (particle && particle.mesh && particle.mesh.parent) {
                    particle.mesh.visible = isVisible(particle.mesh, 2);
                }
            });

            // Apply to pickups - only if they're far from player
            dataFragments.forEach(fragment => {
                if (fragment && fragment.mesh && fragment.mesh.parent) {
                    const distToPlayer = fragment.mesh.position.distanceToSquared(playerPos);
                    fragment.mesh.visible = distToPlayer < 400 || isVisible(fragment.mesh, 1);
                }
            });

            megaDataFragments.forEach(fragment => {
                if (fragment && fragment.mesh && fragment.mesh.parent) {
                    const distToPlayer = fragment.mesh.position.distanceToSquared(playerPos);
                    fragment.mesh.visible = distToPlayer < 400 || isVisible(fragment.mesh, megaDataFragmentRadius);
                }
            });
        }


        function updateCamera() {
            if (!player) return;
            const zoomFactor = isTouchDevice ? 8.5 : 12; // Further zoomed in for touch
            const heightFactor = isTouchDevice ? 12 : 15; // Lower camera height for mobile

            const targetPosition = new THREE.Vector3(player.position.x, heightFactor, player.position.z + zoomFactor);
            camera.position.lerp(targetPosition, 0.08);
            const lookAtTarget = new THREE.Vector3(player.position.x, player.position.y - playerHeight / 4, player.position.z);
            camera.lookAt(lookAtTarget);
            const playerLight = scene.getObjectByProperty('type', 'PointLight');
            if (playerLight) {
                playerLight.position.copy(player.position).add(new THREE.Vector3(0, 3, 0));
            }
        }

        function updateAimTarget() {
            if (!player) return;

            // Auto-aiming logic
            let closestEnemy = null;
            let minDistanceSq = Infinity;
            const autoAimRangeSq = 40 * 40; // Square of the range (e.g., 40 units)

            shapes.forEach(shape => {
                if (shape && shape.userData && shape.userData.health > 0 && shape.parent) { // Ensure shape is valid and alive
                    const distanceSq = player.position.distanceToSquared(shape.position);
                    if (distanceSq < minDistanceSq && distanceSq < autoAimRangeSq) {
                        minDistanceSq = distanceSq;
                        closestEnemy = shape;
                    }
                }
            });

            if (closestEnemy) {
                aimTarget.copy(closestEnemy.position);
            } else {
                // If no enemies in range, aim in the direction player is moving,
                // or just forward if stationary.
                const moveDir = new THREE.Vector3();
                if (moveState.forward) moveDir.z -= 1;
                if (moveState.backward) moveDir.z += 1;
                if (moveState.left) moveDir.x -= 1;
                if (moveState.right) moveDir.x += 1;

                if (moveDir.lengthSq() > 0.01) {
                    moveDir.normalize();
                } else {
                    // Default to player's current facing direction if not moving
                    player.getWorldDirection(moveDir);
                    moveDir.y = 0; // Project to XZ plane
                    if (moveDir.lengthSq() < 0.01) moveDir.set(0, 0, -1); // Absolute fallback
                    moveDir.normalize();
                }
                aimTarget.copy(player.position).add(moveDir.multiplyScalar(15)); // Aim 15 units in that direction
            }
        }


        function updateShapes(deltaTime) {
            // Calculate screen despawn threshold once per frame
            const screenEdges = getScreenEdgesInWorldSpace();
            let despawnDistanceThreshold = MIN_ENEMY_DESPAWN_DISTANCE; // Default

            if (player && screenEdges.valid) { // Ensure player exists for reference
                // Use player position for more accurate "distance from player's view"
                const referenceX = player.position.x;
                const referenceZ = player.position.z;

                // Effective screen "radius" based on current view relative to player
                const effectiveScreenRadius = Math.max(
                    Math.abs(referenceX - screenEdges.minX),
                    Math.abs(referenceX - screenEdges.maxX),
                    Math.abs(referenceZ - screenEdges.minZ),
                    Math.abs(referenceZ - screenEdges.maxZ)
                );
                despawnDistanceThreshold = Math.min(MAX_ENEMY_DESPAWN_DISTANCE, Math.max(MIN_ENEMY_DESPAWN_DISTANCE, effectiveScreenRadius + (effectiveScreenRadius * ENEMY_DESPAWN_DISTANCE_FACTOR)));
            }


            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                // --- Initial Guards ---
                if (!shape || !shape.userData || !shape.parent) {
                    if (shape && !shape.parent) shapes.splice(i, 1);
                    continue;
                }
                const typeData = ENEMY_TYPES[shape.userData.type];
                if (!typeData) {
                    console.warn(`updateShapes: Missing typeData for ${shape.userData.type}, removing shape.`);
                    scene.remove(shape);
                    shape.geometry?.dispose();
                    if (shape.material) { Array.isArray(shape.material) ? shape.material.forEach(m => m?.dispose()) : shape.material.dispose(); }
                    shapes.splice(i, 1);
                    continue;
                }
                // --- End Initial Guards ---

                let targetPosition = player.position.clone();
                let currentSpeed = shape.userData.currentSpeed ?? typeData.speed;
                let executeDefaultMovement = true;

                // --- Special Abilities Switch ---
                switch (shape.userData.type) {
                    // ... (YOUR EXISTING FULL SWITCH BLOCK FOR ENEMY ABILITIES, INCLUDING BOSS LOGIC) ...
                    // Make sure this entire switch block is correctly pasted from your working version
                    case 'ICOSAHEDRON_INVADER':
                        shape.userData.distortTimer = (shape.userData.distortTimer || typeData.distortCooldown) - deltaTime;
                        if (shape.userData.distortTimer <= 0) {
                            createTemporaryVisualEffect(shape.position, 3, typeData.color || 0x4B5320, 0.5, true);
                            shape.userData.distortTimer = typeData.distortCooldown + Math.random() * 5;
                        }
                        break;
                    case 'PRISM_DASHER':
                        executeDefaultMovement = false;
                        shape.userData.dashTimer = (shape.userData.dashTimer || typeData.dashCooldown) - deltaTime;
                        if (!shape.userData.isDashing && shape.userData.dashTimer <= 0) {
                            shape.userData.isDashing = true;
                            shape.userData.dashTargetPos = player.position.clone();
                            shape.userData.dashDir = new THREE.Vector3().subVectors(shape.userData.dashTargetPos, shape.position).normalize();
                            shape.userData.dashTimeLeft = typeData.dashDuration;
                            shape.userData.currentSpeed = typeData.dashSpeed;
                        }
                        if (shape.userData.isDashing) {
                            shape.userData.dashTimeLeft -= deltaTime;
                            if (shape.userData.dashTimeLeft <= 0) {
                                shape.userData.isDashing = false;
                                shape.userData.dashTimer = typeData.dashCooldown + Math.random();
                                shape.userData.currentSpeed = typeData.speed;
                            } else {
                                shape.position.add(shape.userData.dashDir.clone().multiplyScalar(shape.userData.currentSpeed * deltaTime));
                            }
                        } else {
                            shape.userData.currentSpeed = typeData.speed;
                            shape.lookAt(player.position.x, shape.position.y, player.position.z);
                        }
                        break;
                    case 'CYLINDER_CORRUPTER':
                        const dirToPlayerCorrupt = new THREE.Vector3().subVectors(player.position, shape.position);
                        if (dirToPlayerCorrupt.lengthSq() > 0.01) dirToPlayerCorrupt.normalize();
                        const perpendicularDir = new THREE.Vector3(-dirToPlayerCorrupt.z, 0, dirToPlayerCorrupt.x);
                        shape.userData.weaveTimer = (shape.userData.weaveTimer || 0) + deltaTime * 5;
                        const weaveOffset = perpendicularDir.multiplyScalar(Math.sin(shape.userData.weaveTimer) * 1.0);
                        targetPosition = player.position.clone().add(weaveOffset);
                        break;
                    case 'SPHERE_SPLITTER':
                        if (shape.userData.generation === 1) {
                            shape.userData.bounceTimer = (shape.userData.bounceTimer || 0) + deltaTime * 6;
                            const baseSplitterY = shape.radius || (typeData.size[0] || 0.5);
                            shape.position.y = baseSplitterY + Math.abs(Math.sin(shape.userData.bounceTimer)) * 0.4;
                        }
                        break;
                    case 'DODECAHEDRON_DRIFTER':
                        const vecToShape = new THREE.Vector3().subVectors(shape.position, player.position);
                        const distToShape = vecToShape.length();
                        if (distToShape > 0.01) vecToShape.normalize();
                        const playerLookDir = new THREE.Vector3();
                        player.getWorldDirection(playerLookDir);
                        playerLookDir.y = 0;
                        if (playerLookDir.lengthSq() > 0.01) playerLookDir.normalize();
                        else playerLookDir.set(0, 0, -1);
                        const dotProd = playerLookDir.dot(vecToShape);
                        shape.userData.shiftTimer = (shape.userData.shiftTimer || typeData.shiftCooldown) - deltaTime;
                        if (shape.userData.shiftTimer <= 0 && (dotProd < 0.1 || distToShape > 15)) {
                            const shiftDist = 6 + Math.random() * 4;
                            const behindPos = player.position.clone().add(playerLookDir.clone().multiplyScalar(-shiftDist));
                            behindPos.x += (Math.random() - 0.5) * 4;
                            behindPos.z += (Math.random() - 0.5) * 4;
                            behindPos.x = Math.max(-WORLD_BOUNDARY + shape.radius, Math.min(WORLD_BOUNDARY - shape.radius, behindPos.x));
                            behindPos.z = Math.max(-WORLD_BOUNDARY + shape.radius, Math.min(WORLD_BOUNDARY - shape.radius, behindPos.z));
                            createTemporaryVisualEffect(shape.position, 1.5, typeData.color || 0x181818, 0.2);
                            shape.position.set(behindPos.x, shape.height / 2, behindPos.z);
                            createTemporaryVisualEffect(shape.position, 1.5, typeData.color || 0x181818, 0.2);
                            shape.userData.shiftTimer = typeData.shiftCooldown + Math.random() * 2;
                        }
                        break;
                    case 'CONE_CASTER':
                        shape.userData.shardTimer = (shape.userData.shardTimer || typeData.shardCooldown) - deltaTime;
                        if (shape.userData.shardTimer <= 0 && shape.position.distanceTo(player.position) < 18) {
                            const shardDirection = new THREE.Vector3().subVectors(player.position, shape.position);
                            if (shardDirection.lengthSq() > 0.01) shardDirection.normalize();
                            else shardDirection.set(0, 0, -1);
                            const enemyProjectile = { /* ... */ mesh: new THREE.Object3D(), velocity: shardDirection.clone().multiplyScalar(baseProjectileSpeed * 0.6), damage: typeData.deathBurstDamage || 10, weaponId: 'ENEMY_SHARD', duration: 4, isEnemyProjectile: true, radius: projectileRadius * 0.8 };
                            const projMesh = new THREE.Mesh(new THREE.ConeGeometry(enemyProjectile.radius, enemyProjectile.radius * 3, 4), new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffcc33, emissiveIntensity: 0.5 }));
                            const startOffset = shardDirection.clone().normalize().multiplyScalar((shape.radius || 0.5) + enemyProjectile.radius + 0.1);
                            projMesh.position.copy(shape.position).add(startOffset);
                            projMesh.position.y = shape.position.y;
                            enemyProjectile.mesh = projMesh;
                            projectiles.push(enemyProjectile); scene.add(projMesh);
                            shape.userData.shardTimer = typeData.shardCooldown + Math.random() * 2;
                        }
                        break;
                    case 'BOSS_OCTA_PRIME':
                        executeDefaultMovement = false;
                        const bossData = shape.userData;
                        const bossParams = typeData;
                        if (bossData.attackState === 'MOVING') { bossData.attackCooldownTimer -= deltaTime; }
                        switch (bossData.attackState) {
                            case 'MOVING':
                                bossData.currentSpeed = bossParams.speed;
                                const dirToPlayerBoss = new THREE.Vector3().subVectors(targetPosition, shape.position);
                                dirToPlayerBoss.y = 0;
                                if (dirToPlayerBoss.lengthSq() > 0.1) { shape.position.add(dirToPlayerBoss.normalize().multiplyScalar(bossData.currentSpeed * deltaTime)); }
                                shape.lookAt(player.position.x, shape.position.y, player.position.z);
                                if (bossData.attackCooldownTimer <= 0) {
                                    let nextPatternIndex = Math.floor(Math.random() * bossParams.attackPatterns.length);
                                    bossData.currentAttackPattern = bossParams.attackPatterns[nextPatternIndex];
                                    console.log("Boss starting attack:", bossData.currentAttackPattern);
                                    switch (bossData.currentAttackPattern) {
                                        case 'PULSE': bossData.attackState = 'CHARGING_PULSE'; bossData.attackStateTimer = bossParams.pulseChargeTime; shape.material.emissive.setHex(bossParams.pulseColor || 0xFF69B4); shape.material.emissiveIntensity = 1.0; break;
                                        case 'RAPID_FIRE': bossData.attackState = 'CHARGING_RAPID'; bossData.attackStateTimer = 0.5; bossData.rapidFireTargetPos = player.position.clone(); shape.material.emissive.setHex(0xFFFF00); shape.material.emissiveIntensity = 1.0; break;
                                        case 'DASH_SLAM': bossData.attackState = 'CHARGING_DASH'; bossData.attackStateTimer = bossParams.dashChargeTime; shape.material.emissive.setHex(0x00FFFF); shape.material.emissiveIntensity = 1.2; break;
                                        case 'SUMMON': bossData.attackState = 'CHARGING_SUMMON'; bossData.attackStateTimer = bossParams.summonChargeTime; shape.material.emissive.setHex(0x00FF00); shape.material.emissiveIntensity = 1.0; break;
                                        default: console.warn("Unknown boss attack:", bossData.currentAttackPattern); bossData.attackState = 'MOVING'; bossData.attackCooldownTimer = 1.0; break;
                                    }
                                }
                                break;
                            case 'CHARGING_PULSE':
                                bossData.attackStateTimer -= deltaTime;
                                if (Math.random() < 0.5) createBurstEffect(shape.position, 1, bossParams.pulseColor, 1 + Math.random(), 0.15);
                                shape.lookAt(player.position.x, shape.position.y, player.position.z);
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'PULSING'; bossData.attackStateTimer = 0.3;
                                    createTemporaryVisualEffect(shape.position, bossParams.pulseRadius, bossParams.pulseColor, 0.4, true);
                                    playSoundSynth('shoot_basic', 0.7, { pitch: 150 });
                                    if (player.position.distanceTo(shape.position) < bossParams.pulseRadius + playerRadius) {
                                        playerShield -= bossParams.pulseDamage; createHitEffect(player, bossParams.pulseColor, 0.2); playSoundSynth('player_hit', 0.6);
                                        if (playerShield <= 0 && currentGameState === GameState.Playing) { gameOver(); return; }
                                    }
                                }
                                break;
                            case 'PULSING':
                                bossData.attackStateTimer -= deltaTime;
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'MOVING'; bossData.attackCooldownTimer = bossParams.attackCooldown;
                                    shape.material.emissive.setHex(bossParams.emissive || 0x8B008B); shape.material.emissiveIntensity = bossParams.emissiveIntensity || 0.6;
                                }
                                break;
                            case 'CHARGING_RAPID':
                                bossData.attackStateTimer -= deltaTime;
                                if (bossData.rapidFireTargetPos) { shape.lookAt(bossData.rapidFireTargetPos.x, shape.position.y, bossData.rapidFireTargetPos.z); }
                                else { shape.lookAt(player.position.x, shape.position.y, player.position.z); }
                                if (bossData.attackStateTimer <= 0) { bossData.attackState = 'FIRING_RAPID'; bossData.rapidFireBursts = 5; bossData.rapidFireBurstTimer = 0.12; }
                                break;
                            case 'FIRING_RAPID':
                                bossData.rapidFireBurstTimer -= deltaTime;
                                if (bossData.rapidFireTargetPos) { shape.lookAt(bossData.rapidFireTargetPos.x, shape.position.y, bossData.rapidFireTargetPos.z); }
                                if (bossData.rapidFireBurstTimer <= 0 && bossData.rapidFireBursts > 0) {
                                    bossData.rapidFireBursts--; bossData.rapidFireBurstTimer = 0.12;
                                    const fireDirBoss = new THREE.Vector3().subVectors(bossData.rapidFireTargetPos || player.position, shape.position);
                                    if (fireDirBoss.lengthSq() < 0.01) fireDirBoss.set(0, 0, -1); fireDirBoss.normalize();
                                    const projRadiusBoss = projectileRadius * 1.2;
                                    const bossProjectile = { /* ... */ mesh: null, velocity: fireDirBoss.clone().multiplyScalar(baseProjectileSpeed * 1.5), damage: (bossParams.rapidFireDamage || 15) * bossParams.damageMultiplier, weaponId: 'BOSS_RAPID', duration: 3, isEnemyProjectile: true, radius: projRadiusBoss };
                                    const projMeshBoss = new THREE.Mesh(new THREE.SphereGeometry(projRadiusBoss, 6, 4), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                                    const offsetBoss = fireDirBoss.clone().multiplyScalar((shape.radius || 1.5) + projRadiusBoss + 0.2);
                                    projMeshBoss.position.copy(shape.position).add(offsetBoss); projMeshBoss.position.y = shape.position.y;
                                    bossProjectile.mesh = projMeshBoss; projectiles.push(bossProjectile); scene.add(projMeshBoss);
                                    playSoundSynth('shoot_basic', 0.4, { pitch: 880 + Math.random() * 100 });
                                }
                                if (bossData.rapidFireBursts <= 0) {
                                    bossData.attackState = 'MOVING'; bossData.attackCooldownTimer = bossParams.attackCooldown;
                                    shape.material.emissive.setHex(bossParams.emissive || 0x8B008B); shape.material.emissiveIntensity = bossParams.emissiveIntensity || 0.6;
                                }
                                break;
                            case 'CHARGING_DASH':
                                bossData.attackStateTimer -= deltaTime;
                                shape.position.x += Math.sin(gameTime * 60) * 0.08; shape.position.z += Math.cos(gameTime * 60) * 0.08;
                                shape.lookAt(player.position.x, shape.position.y, player.position.z);
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'DASHING'; bossData.attackStateTimer = bossParams.dashDuration;
                                    bossData.dashTargetPos = player.position.clone();
                                    bossData.dashDir = new THREE.Vector3().subVectors(bossData.dashTargetPos, shape.position);
                                    if (bossData.dashDir.lengthSq() < 0.01) bossData.dashDir.set(0, 0, -1); bossData.dashDir.normalize();
                                    bossData.currentSpeed = bossParams.speed * bossParams.dashSpeedMultiplier;
                                    playSoundSynth('enemy_hit', 0.8, { pitch: 330 });
                                }
                                break;
                            case 'DASHING':
                                bossData.attackStateTimer -= deltaTime;
                                shape.position.add(bossData.dashDir.clone().multiplyScalar(bossData.currentSpeed * deltaTime));
                                if (Math.random() < 0.4) createBurstEffect(shape.position, 2, 0x00FFFF, 3, 0.25);
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'SLAMMING'; bossData.attackStateTimer = 0.5;
                                    bossData.currentSpeed = bossParams.speed;
                                    createTemporaryVisualEffect(shape.position, bossParams.slamRadius, 0x00FFFF, 0.5, true);
                                    playSoundSynth('enemy_death', 0.9, { isLarge: true });
                                    if (player.position.distanceTo(shape.position) < bossParams.slamRadius + playerRadius) {
                                        playerShield -= bossParams.slamDamage; createHitEffect(player, 0x00FFFF, 0.3); playSoundSynth('player_hit', 0.7);
                                        if (playerShield <= 0 && currentGameState === GameState.Playing) { gameOver(); return; }
                                    }
                                }
                                break;
                            case 'SLAMMING':
                                bossData.attackStateTimer -= deltaTime;
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'MOVING'; bossData.attackCooldownTimer = bossParams.attackCooldown;
                                    shape.material.emissive.setHex(bossParams.emissive || 0x8B008B); shape.material.emissiveIntensity = bossParams.emissiveIntensity || 0.6;
                                }
                                break;
                            case 'CHARGING_SUMMON':
                                bossData.attackStateTimer -= deltaTime;
                                shape.rotation.y += deltaTime * 6;
                                if (Math.random() < 0.2) createBurstEffect(shape.position, 1, 0x00FF00, 1, 0.2);
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'SUMMONING'; bossData.attackStateTimer = 0.2;
                                    playSoundSynth('level_up', 0.7);
                                    const summonType = bossParams.summonType || 'TETRA_SWARMER';
                                    const minionTypeData = ENEMY_TYPES[summonType];
                                    if (!minionTypeData) { console.warn("Boss summon type invalid:", summonType); }
                                    else {
                                        for (let j = 0; j < bossParams.summonCount; j++) {
                                            const angleSummon = (j / bossParams.summonCount) * Math.PI * 2 + (Math.random() * 0.5 - 0.25);
                                            const offsetDistSummon = (shape.radius || 1.5) + 1.0 + Math.random();
                                            const spawnPosSummon = shape.position.clone().add(new THREE.Vector3(Math.cos(angleSummon) * offsetDistSummon, 0, Math.sin(angleSummon) * offsetDistSummon));
                                            spawnPosSummon.x = Math.max(-WORLD_BOUNDARY + 1, Math.min(WORLD_BOUNDARY - 1, spawnPosSummon.x));
                                            spawnPosSummon.z = Math.max(-WORLD_BOUNDARY + 1, Math.min(WORLD_BOUNDARY - 1, spawnPosSummon.z));
                                            spawnEnemyByType(summonType, spawnPosSummon);
                                        }
                                    }
                                }
                                break;
                            case 'SUMMONING':
                                bossData.attackStateTimer -= deltaTime;
                                if (bossData.attackStateTimer <= 0) {
                                    bossData.attackState = 'MOVING'; bossData.attackCooldownTimer = bossParams.attackCooldown;
                                    shape.material.emissive.setHex(bossParams.emissive || 0x8B008B); shape.material.emissiveIntensity = bossParams.emissiveIntensity || 0.6;
                                    shape.rotation.y = shape.userData.initialRotationY || 0;
                                }
                                break;
                        }
                        break;
                    default:
                        break;
                }
                // --- End Special Abilities Switch ---

                // --- Default Movement (Applies if executeDefaultMovement is true) ---
                if (executeDefaultMovement) {
                    if (currentSpeed > 0) {
                        const direction = new THREE.Vector3().subVectors(targetPosition, shape.position);
                        direction.y = 0;
                        if (direction.lengthSq() > 0.01) {
                            direction.normalize();
                            shape.position.add(direction.multiplyScalar(currentSpeed * deltaTime));
                        }
                    }
                    if (!shape.userData.isDashing) {
                        shape.lookAt(player.position.x, shape.position.y, player.position.z);
                    }
                }
                // --- End Default Movement Block ---

                // --- <<<< NEW DESPAWN LOGIC STARTS HERE >>>> ---
                if (!typeData.isBoss) {
                    const distanceToPlayer = player ? player.position.distanceTo(shape.position) : Infinity;

                    // Optional: Add a grace period using spawnTimestamp
                    // const gracePeriod = 3.0; // 3 seconds
                    // if (player && (gameTime - (shape.userData.spawnTimestamp || 0) > gracePeriod) && 
                    //     distanceToPlayer > despawnDistanceThreshold) {

                    if (player && distanceToPlayer > despawnDistanceThreshold) { // Simpler check without grace period first
                        // console.log(`Despawning ${shape.userData.type} dist: ${distanceToPlayer.toFixed(1)} > ${despawnDistanceThreshold.toFixed(1)}`);
                        scene.remove(shape);
                        shape.geometry?.dispose();
                        if (shape.material) {
                            if (Array.isArray(shape.material)) {
                                shape.material.forEach(m => m?.dispose());
                            } else {
                                shape.material.dispose();
                            }
                        }
                        shapes.splice(i, 1);
                        continue;
                    }
                }
                // --- <<<< NEW DESPAWN LOGIC ENDS HERE >>>> ---

                // --- Collision with Obstacles (Apply universally after position updates) ---
                staticLevelObjects.forEach(obstacle => {
                    if (obstacle.userData.isObstacle) {
                        const distToObstacle = shape.position.distanceTo(obstacle.position);
                        const collisionThresholdObs = (shape.radius || 0.5) + (obstacle.userData.obstacleRadius || 0.5);
                        if (distToObstacle < collisionThresholdObs) {
                            const overlapObs = collisionThresholdObs - distToObstacle;
                            const pushFromObstacle = new THREE.Vector3().subVectors(shape.position, obstacle.position);
                            if (pushFromObstacle.lengthSq() < 0.01) pushFromObstacle.set(Math.random() - 0.5, 0, Math.random() - 0.5);
                            pushFromObstacle.y = 0;
                            pushFromObstacle.normalize();
                            shape.position.add(pushFromObstacle.multiplyScalar(overlapObs * 1.01));
                        }
                    }
                });
                // --- End Obstacle Collision ---

                // --- World Boundary Clamp (Apply universally) ---
                const shapeRadiusForBounds = shape.radius || 0.5;
                shape.position.x = Math.max(-WORLD_BOUNDARY + shapeRadiusForBounds, Math.min(WORLD_BOUNDARY - shapeRadiusForBounds, shape.position.x));
                shape.position.z = Math.max(-WORLD_BOUNDARY + shapeRadiusForBounds, Math.min(WORLD_BOUNDARY - shapeRadiusForBounds, shape.position.z));
                // --- End World Boundary Clamp ---

                // --- Default Enemy Rotation (Non-Boss) ---
                if (!typeData.isBoss && !shape.userData.isDashing) {
                    shape.rotation.x += deltaTime * 0.1 * (typeData.name === 'Cube Crusher' ? 1 : 0.5);
                    shape.rotation.z += deltaTime * 0.05 * (typeData.name === 'Cube Crusher' ? 1 : 0.5);
                }
                // --- End Default Enemy Rotation ---

            } // End shapes loop
        } // End updateShapes function

        function updateProjectiles(deltaTime) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                if (!projectile || !projectile.mesh) {
                    projectiles.splice(i, 1);
                    continue;
                }

                projectile.mesh.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
                projectile.mesh.rotation.x += deltaTime * 2;
                projectile.mesh.rotation.y += deltaTime * 1;

                let hitObstacle = false;
                // Player projectiles check collision with static obstacles
                if (!projectile.isEnemyProjectile) {
                    for (const obstacle of staticLevelObjects) {
                        if (obstacle.userData.isObstacle) {
                            const distance = projectile.mesh.position.distanceTo(obstacle.position);
                            // Ensure obstacleRadius is valid, fallback to a small default if not
                            const obsRadius = obstacle.userData.obstacleRadius || 0.5;
                            const collisionThreshold = projectileRadius + obsRadius * 0.9; // *0.9 to make it feel a bit tighter

                            if (distance < collisionThreshold) {
                                // Create a small burst effect at the obstacle's color
                                createBurstEffect(projectile.mesh.position, 5, obstacle.material.color.getHex(), 2, 0.2);
                                hitObstacle = true;
                                break; // Projectile hits one obstacle and is done
                            }
                        }
                    }
                }

                if (hitObstacle && !projectile.tags?.includes('piercing_obstacle')) { // Piercing_obstacle tag could be added
                    // Return projectile to pool instead of disposing
                    scene.remove(projectile.mesh);
                    returnToPool('projectiles', projectile.mesh, (mesh) => {
                        // Reset projectile properties for reuse
                        mesh.visible = false;
                    });
                    projectiles.splice(i, 1);
                    continue;
                }

                // Despawn projectile if it has a duration and it expired
                if (projectile.duration) {
                    projectile.duration -= deltaTime;
                    if (projectile.duration <= 0) {
                        // Return projectile to pool instead of disposing
                        scene.remove(projectile.mesh);
                        returnToPool('projectiles', projectile.mesh, (mesh) => {
                            // Reset projectile properties for reuse
                            mesh.visible = false;
                        });
                        projectiles.splice(i, 1);
                        continue;
                    }
                }

                // Despawn projectile if it goes too far out of bounds
                if (projectile.mesh.position.distanceTo(player.position) > WORLD_BOUNDARY * 1.6) { // Increased despawn range
                    // Return projectile to pool instead of disposing
                    scene.remove(projectile.mesh);
                    returnToPool('projectiles', projectile.mesh, (mesh) => {
                        // Reset projectile properties for reuse
                        mesh.visible = false;
                    });
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateDataFragments(deltaTime) {
            if (!player) return;
            for (let i = dataFragments.length - 1; i >= 0; i--) {
                const fragment = dataFragments[i];
                if (!fragment || !fragment.mesh) {
                    dataFragments.splice(i, 1);
                    continue;
                }
                fragment.mesh.rotation.y += deltaTime * 2.5;
                fragment.mesh.rotation.x += deltaTime * 1.5;

                const distanceToPlayer = fragment.mesh.position.distanceTo(player.position);

                // --- XP CONSOLIDATION LOGIC ---
                if (distanceToPlayer > XP_CONSOLIDATION_DISTANCE) {
                    accumulatedOffScreenXP += fragment.xpValue;
                    scene.remove(fragment.mesh);
                    if (fragment.mesh.geometry) fragment.mesh.geometry.dispose();
                    if (fragment.mesh.material) fragment.mesh.material.dispose();
                    dataFragments.splice(i, 1); // Remove from array
                    continue; // Move to the next fragment, skip attraction/collection for this one
                }
                // --- END XP CONSOLIDATION LOGIC ---

                // Attract if within 1.8x the collection radius, speed increases as it gets closer
                if (distanceToPlayer < xpCollectionRadius * 1.8) {
                    const direction = new THREE.Vector3().subVectors(player.position, fragment.mesh.position).normalize();
                    const speedMultiplier = Math.max(1, 3 * (1 - distanceToPlayer / (xpCollectionRadius * 1.8)));
                    fragment.mesh.position.add(direction.multiplyScalar(baseDataFragmentSpeed * speedMultiplier * deltaTime));
                }
            }
        }

        function updateMegaDataFragments(deltaTime) {
            if (!player) return;
            for (let i = megaDataFragments.length - 1; i >= 0; i--) {
                const fragment = megaDataFragments[i];
                if (!fragment || !fragment.mesh) {
                    megaDataFragments.splice(i, 1);
                    continue;
                }
                // Simple rotation
                fragment.mesh.rotation.y += deltaTime * 1.8;
                fragment.mesh.rotation.x -= deltaTime * 0.9;

                // Pulsing scale animation for visual appeal
                fragment.pulseTimer = (fragment.pulseTimer || 0) + deltaTime * 3;
                const scalePulse = 1.0 + Math.sin(fragment.pulseTimer) * 0.12;
                fragment.mesh.scale.set(scalePulse, scalePulse, scalePulse);

                const distanceToPlayer = fragment.mesh.position.distanceTo(player.position);
                // Attract if within a larger radius or always attract slowly
                const attractionRadius = xpCollectionRadius * 2.2; // Larger attraction radius for mega orbs
                if (distanceToPlayer < attractionRadius) {
                    const direction = new THREE.Vector3().subVectors(player.position, fragment.mesh.position).normalize();
                    // Slower base speed but stronger pull as it gets very close
                    const speedMultiplier = Math.max(0.7, 3.5 * (1 - distanceToPlayer / attractionRadius));
                    fragment.mesh.position.add(direction.multiplyScalar(baseDataFragmentSpeed * 0.8 * speedMultiplier * deltaTime));
                }
            }
        }

        function updateHitEffects(deltaTime) {
            for (let i = hitEffects.length - 1; i >= 0; i--) {
                const effect = hitEffects[i];
                effect.timer -= deltaTime;
                if (effect.timer <= 0) {
                    if (effect.target && effect.target.material) {
                        const material = effect.target.material;
                        // Ensure matInstance is the actual material, not an array if multi-material object
                        const matInstance = Array.isArray(material) ? material[0] : material;
                        if (matInstance) {
                            if (effect.isEmissive && matInstance.emissive && matInstance.emissive.isColor) {
                                matInstance.emissive.setHex(effect.originalColor);
                            } else if (matInstance.color && matInstance.color.isColor) { // For MeshBasicMaterial and others
                                matInstance.color.setHex(effect.originalColor);
                            }
                            // Restore opacity if it was part of the effect
                            if (typeof matInstance.opacity !== 'undefined' && typeof effect.originalOpacity !== 'undefined') {
                                matInstance.opacity = effect.originalOpacity;
                                matInstance.transparent = effect.originalOpacity < 1; // Set transparency based on original
                            }
                        }
                    }
                    hitEffects.splice(i, 1);
                } else {
                    // Optional: Could add a fade out to the hit effect color/emissive intensity here
                    if (effect.target && effect.target.material) {
                        const material = effect.target.material;
                        const matInstance = Array.isArray(material) ? material[0] : material;
                        if (matInstance && effect.isEmissive && matInstance.emissiveIntensity !== undefined) {
                            matInstance.emissiveIntensity = (effect.timer / (effect.duration || 0.15)) * 0.8 + 0.2; // Fade intensity
                        }
                    }
                }
            }
        }

        function updateWeapons(deltaTime) {
            if (!player) return;
            playerWeapons.forEach(weapon => {
                if (weapon.level > 0) {
                    if (weapon.fire) weapon.fire(deltaTime);
                    if (weapon.updateWeaponSystem) weapon.updateWeaponSystem(weapon, deltaTime);
                }
            });
        }

        function updateUI() {
            if (shieldElement) shieldElement.textContent = Math.max(0, playerShield).toFixed(0);
            if (scoreElement) scoreElement.textContent = score;
            if (shapeCountElement) shapeCountElement.textContent = shapes.length;
            if (levelElement) levelElement.textContent = playerLevel;

            const xpProgress = Math.min(1, currentXP / xpToNextLevel) * 100;
            if (xpBarFillElement) xpBarFillElement.style.width = `${xpProgress}%`;

            if (timerElement) {
                const totalSeconds = Math.floor(gameTime);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
        }

        function updateWeaponUI() {
            if (!weaponIndicatorElement) return;
            weaponIndicatorElement.innerHTML = ''; // Clear existing icons
            playerWeapons.forEach(weapon => {
                if (weapon.level > 0) {
                    const iconDiv = document.createElement('div');
                    iconDiv.classList.add('icon-display');
                    if (weapon.isEvolved) {
                        iconDiv.classList.add('evolved');
                    }
                    iconDiv.innerHTML = `<span>${weapon.icon || '?'}</span> <span>${weapon.isEvolved ? 'EVO' : 'L' + weapon.level}</span>`;
                    weaponIndicatorElement.appendChild(iconDiv);
                }
            });
        }

        function updateItemUI() {
            if (!itemIndicatorElement) return;
            itemIndicatorElement.innerHTML = ''; // Clear existing icons
            playerItems.forEach(item => {
                if (item.level > 0) {
                    const iconDiv = document.createElement('div');
                    iconDiv.classList.add('icon-display');
                    iconDiv.innerHTML = `<span>${item.icon || '?'}</span> <span>L${item.level}</span>`;
                    itemIndicatorElement.appendChild(iconDiv);
                }
            });
        }

        function updatePickups(deltaTime) {
            // Geometric Caches - with opening animation
            for (let i = geometricCaches.length - 1; i >= 0; i--) {
                const cache = geometricCaches[i];
                if (!cache || !cache.mesh) {
                    geometricCaches.splice(i, 1);
                    continue;
                }
                if (cache.mesh.userData.isOpeningCache) {
                    cache.mesh.userData.openAnimationTimer += deltaTime;
                    const progress = cache.mesh.userData.openAnimationTimer / cache.mesh.userData.openAnimationDuration;

                    if (progress < 1) {
                        // Example animation: scale pulse and rotate fast
                        const scaleProg = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
                        const currentScale = cache.mesh.userData.originalScale.x * (1 + scaleProg * 0.5);
                        cache.mesh.scale.set(currentScale, currentScale, currentScale);
                        cache.mesh.rotation.y += deltaTime * 15 * (1 - progress); // Faster at start
                        cache.mesh.rotation.x += deltaTime * 10 * (1 - progress);
                        // Maybe emit a few particles
                        if (Math.random() < 0.2) {
                            createBurstEffect(cache.mesh.position, 1, 0xFFD700, 1 + Math.random() * 2, 0.3 + Math.random() * 0.3);
                        }
                    } else {
                        // Animation finished
                        grantCacheRewards(); // Grant rewards now
                        scene.remove(cache.mesh);
                        if (cache.mesh.geometry) cache.mesh.geometry.dispose();
                        if (cache.mesh.material) cache.mesh.material.dispose();
                        geometricCaches.splice(i, 1);
                    }
                } else {
                    // Regular bobbing before collection
                    cache.bobTimer = (cache.bobTimer || 0) + deltaTime * 3;
                    cache.mesh.position.y = cache.baseY + Math.sin(cache.bobTimer) * 0.1;
                    cache.mesh.rotation.y += deltaTime * 0.5;
                }
            }

            // Repair Nodes
            repairNodes.forEach(pickup => {
                if (pickup.mesh) {
                    pickup.mesh.rotation.y += deltaTime * 1.5;
                    pickup.pulseTimer = (pickup.pulseTimer || 0) + deltaTime * 3;
                    const pulseScale = 1.0 + Math.sin(pickup.pulseTimer) * 0.05;
                    pickup.mesh.scale.set(pulseScale, pulseScale, pulseScale);
                    pickup.mesh.children.forEach(childMesh => {
                        if (childMesh.material) { // MeshBasicMaterial uses opacity
                            childMesh.material.opacity = 0.7 + Math.abs(Math.sin(pickup.pulseTimer * 0.5)) * 0.3;
                        }
                    });
                }
            });

            // Energy Cores
            energyCores.forEach(pickup => {
                if (pickup.mesh) {
                    pickup.mesh.rotation.y -= deltaTime * 1.0;
                    pickup.mesh.rotation.x += deltaTime * 0.5;
                    pickup.pulseTimer = (pickup.pulseTimer || 0) + deltaTime * 4;
                    const scale = 1.0 + Math.sin(pickup.pulseTimer) * 0.08;
                    pickup.mesh.scale.set(scale, scale, scale);
                    if (pickup.mesh.material) { // MeshBasicMaterial uses opacity
                        pickup.mesh.material.opacity = 0.8 + Math.abs(Math.sin(pickup.pulseTimer * 0.5)) * 0.2;
                    }
                }
            });
        }

        function createBurstEffect(position, count = 20, color = 0xffffff, speed = 3, duration = 0.5, particleType = 'default') {
            // Cache materials for reuse
            if (!window.cachedParticleMaterials) {
                window.cachedParticleMaterials = {};
            }

            // Create or get cached material
            const materialKey = `${color}_${particleType}`;
            if (!window.cachedParticleMaterials[materialKey]) {
                if (particleType === 'spiral') {
                    window.cachedParticleMaterials[materialKey] = new THREE.PointsMaterial({ 
                        color: color, 
                        size: 0.1, 
                        transparent: true, 
                        opacity: 1.0, 
                        sizeAttenuation: true, 
                        depthWrite: false, 
                        blending: THREE.AdditiveBlending 
                    });
                } else { // default
                    window.cachedParticleMaterials[materialKey] = new THREE.PointsMaterial({ 
                        color: color, 
                        size: 0.15, 
                        transparent: true, 
                        opacity: 0.9, 
                        sizeAttenuation: true, 
                        depthWrite: false, 
                        blending: THREE.AdditiveBlending 
                    });
                }
            }
            const particleMaterial = window.cachedParticleMaterials[materialKey];

            // Get particle system from pool or create new one
            const points = getFromPool('particles', () => {
                const geo = new THREE.BufferGeometry();
                const vertices = new Float32Array(count * 3); // Pre-allocate for maximum expected count
                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                return new THREE.Points(geo, particleMaterial);
            });

            // Update geometry if needed
            if (points.geometry.attributes.position.count !== count) {
                const vertices = new Float32Array(count * 3);
                points.geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            }

            // Update material if needed
            if (points.material !== particleMaterial) {
                points.material = particleMaterial;
            }

            // Reset properties
            points.visible = true;
            points.material.opacity = particleType === 'spiral' ? 1.0 : 0.9;

            // Set initial positions
            const positions = points.geometry.attributes.position;
            for (let i = 0; i < count; i++) {
                positions.setXYZ(i, position.x, position.y, position.z);
            }
            positions.needsUpdate = true;

            // Add to scene if not already there
            if (!points.parent) {
                scene.add(points);
            }

            // Create particle data
            const particleData = { 
                mesh: points, 
                velocities: [], 
                life: duration, 
                type: particleType, 
                startTime: clock.getElapsedTime(), 
                initialPositions: [] 
            };

            // Set velocities and initial positions
            for (let i = 0; i < count; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(speed * (0.5 + Math.random() * 0.5));

                particleData.velocities.push(velocity);
                particleData.initialPositions.push(position.clone()); // For spiral
            }

            particles.push(particleData);
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= deltaTime;
                if (p.life <= 0) {
                    // Return particle to pool instead of disposing
                    scene.remove(p.mesh);
                    returnToPool('particles', p.mesh, (mesh) => {
                        // Reset particle properties for reuse
                        mesh.visible = false;
                        // Don't dispose geometry or material as they're now pooled
                    });
                    particles.splice(i, 1);
                    continue;
                }

                const positions = p.mesh.geometry.attributes.position;
                const timeElapsed = clock.getElapsedTime() - p.startTime;

                for (let j = 0; j < positions.count; j++) {
                    if (p.type === 'spiral') {
                        const angle = timeElapsed * 5 + (j * 0.3); // Adjust for spiral effect
                        const radius = timeElapsed * p.velocities[j].length() * 0.3; // Expanding radius
                        positions.setX(j, p.initialPositions[j].x + Math.cos(angle) * radius + p.velocities[j].x * deltaTime * 0.1); // Base + spiral + slight drift
                        positions.setY(j, p.initialPositions[j].y + Math.sin(angle * 0.7) * radius * 0.5 + p.velocities[j].y * deltaTime * 0.1); // Y component for spiral
                        positions.setZ(j, p.initialPositions[j].z + Math.sin(angle) * radius + p.velocities[j].z * deltaTime * 0.1);
                    } else { // default burst
                        positions.setX(j, positions.getX(j) + p.velocities[j].x * deltaTime);
                        positions.setY(j, positions.getY(j) + p.velocities[j].y * deltaTime);
                        positions.setZ(j, positions.getZ(j) + p.velocities[j].z * deltaTime);
                    }
                }
                positions.needsUpdate = true;

                // Fade out particles as they age
                p.mesh.material.opacity = Math.max(0, p.life / (p.mesh.material.opacity || 0.5)); // Use original duration for fade
            }
        }

        function spawnEnemyByType(typeId, forcedPosition = null) {
            const typeData = ENEMY_TYPES[typeId];
            if (!typeData) {
                console.warn("Unknown enemy type ID in spawnEnemyByType:", typeId);
                return; // Stop if typeData is not found
            }

            let geometry;
            const sizeParams = typeData.size || []; // Ensure sizeParams is an array

            // --- Geometry Creation ---
            try { // Add try...catch around geometry creation for safety
                switch (typeData.geometryType) {
                    case 'Box':
                        geometry = new THREE.BoxGeometry(
                            sizeParams[0] || 0.8, // width
                            sizeParams[1] || 0.8, // height
                            sizeParams[2] || 0.8  // depth
                        );
                        break;
                    case 'Sphere':
                        geometry = new THREE.SphereGeometry(
                            sizeParams[0] || 0.5, // radius
                            sizeParams[1] || 12,  // widthSegments
                            sizeParams[2] || 8   // heightSegments
                        );
                        break;
                    case 'Cylinder':
                        geometry = new THREE.CylinderGeometry(
                            sizeParams[0] || 0.3, // radiusTop
                            sizeParams[1] || 0.3, // radiusBottom
                            sizeParams[2] || 1.0, // height
                            sizeParams[3] || 8    // radialSegments
                        );
                        break;
                    case 'Cone':
                        geometry = new THREE.ConeGeometry(
                            sizeParams[0] || 0.5, // radius
                            sizeParams[1] || 1.0, // height
                            sizeParams[2] || 8    // radialSegments
                        );
                        break;
                    case 'Icosahedron':
                        geometry = new THREE.IcosahedronGeometry(
                            sizeParams[0] || 0.6, // radius
                            sizeParams[1] || 0    // detail
                        );
                        break;
                    case 'Octahedron':
                        geometry = new THREE.OctahedronGeometry(
                            sizeParams[0] || 0.8, // radius
                            sizeParams[1] || 0    // detail
                        );
                        break;
                    case 'Dodecahedron':
                        geometry = new THREE.DodecahedronGeometry(
                            sizeParams[0] || 0.6, // radius
                            sizeParams[1] || 0    // detail
                        );
                        break;
                    case 'Tetrahedron':
                        geometry = new THREE.TetrahedronGeometry(
                            sizeParams[0] || 0.4, // radius
                            sizeParams[1] || 0    // detail
                        );
                        break;
                    default:
                        console.warn("Unknown geometry type for enemy:", typeId, ". Defaulting to Box.");
                        geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                }
            } catch (geoError) {
                console.error(`Error creating geometry for ${typeId} (${typeData.geometryType}) with params ${sizeParams}:`, geoError);
                console.warn("Falling back to default BoxGeometry.");
                geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8); // Fallback geometry
            }


            // --- Material Creation ---
            const material = new THREE.MeshStandardMaterial({
                color: typeData.color || 0xffffff,       // Default to white if color missing
                roughness: typeData.roughness ?? 0.5,    // Use provided or default 0.5
                metalness: typeData.metalness ?? 0.0,    // Use provided or default 0.0
                flatShading: typeData.flatShading ?? false // Use provided or default false
            });

            // Apply emissive properties separately if they exist in typeData
            if (typeData.emissive) {
                try {
                    material.emissive = new THREE.Color(typeData.emissive);
                    material.emissiveIntensity = typeData.emissiveIntensity ?? 1.0; // Use provided intensity or default 1
                } catch (colorError) {
                    console.error(`Invalid emissive color value for ${typeId}: ${typeData.emissive}`, colorError);
                    // Keep default emissive (black)
                }
            }
            // Store original for hit effect reset (important even if no initial emissive)
            material.originalEmissiveHex = material.emissive ? material.emissive.getHex() : 0x000000;
            // --- End Material Creation ---


            const enemyMesh = new THREE.Mesh(geometry, material);

            const enemySpawnRadius = enemyMesh.radius || 0.5; // Use calculated radius for safety offset

            // <<< --- MOVE spawnVisualOffset DEFINITION HERE --- >>>
            const spawnVisualOffset = enemySpawnRadius + 1.0 + (Math.random() * 1.0); // How far off-screen to spawn

            // --- Spawn Position Calculation ---
            const tempSpawnPosition = new THREE.Vector3(); // Use a temporary variable for calculations

            if (forcedPosition && forcedPosition instanceof THREE.Vector3) {
                // Use the forced position if provided (e.g., for summons or fixed boss spawn)
                tempSpawnPosition.copy(forcedPosition); // CHANGED: spawnPosition -> tempSpawnPosition
            } else {
                // Default: Calculate random position just off one of the screen edges
                const screenEdges = getScreenEdgesInWorldSpace();
                let P_minX, P_maxX, P_minZ, P_maxZ;

                // Use calculated screen edges if valid, otherwise fallback to player-centric area
                if (screenEdges && screenEdges.valid) {
                    P_minX = screenEdges.minX;
                    P_maxX = screenEdges.maxX;
                    P_minZ = screenEdges.minZ;
                    P_maxZ = screenEdges.maxZ;
                } else {
                    // Fallback if screen edges couldn't be determined (e.g., camera not ready)
                    // Spawn in a ring around the player, further out than typical screen edge
                    const fallbackSpawnRingInner = 25; // Min distance from player
                    const fallbackSpawnRingOuter = 35; // Max distance from player
                    const angle = Math.random() * Math.PI * 2;
                    const dist = fallbackSpawnRingInner + Math.random() * (fallbackSpawnRingOuter - fallbackSpawnRingInner);
                    tempSpawnPosition.set( // CHANGED: spawnPosition -> tempSpawnPosition
                        player.position.x + Math.cos(angle) * dist,
                        0, // Y will be set later
                        player.position.z + Math.sin(angle) * dist
                    );
                    // console.warn(`Spawning ${typeId} using fallback ring due to invalid screen edges.`);
                    // Skip edge-specific logic if using fallback ring
                }

                // If not using fallback ring (i.e., screenEdges were valid)
                if (!(screenEdges && !screenEdges.valid)) {
                    const side = Math.floor(Math.random() * 4); // 0: Top, 1: Bottom, 2: Left, 3: Right
                    let x, z;

                    switch (side) {
                        case 0: // Spawn just ABOVE the top visible edge (maxZ)
                            x = P_minX + Math.random() * (P_maxX - P_minX); // Random X along the visible width
                            z = P_maxZ + spawnVisualOffset;
                            break;
                        case 1: // Spawn just BELOW the bottom visible edge (minZ)
                            x = P_minX + Math.random() * (P_maxX - P_minX);
                            z = P_minZ - spawnVisualOffset;
                            break;
                        case 2: // Spawn just LEFT of the left visible edge (minX)
                            x = P_minX - spawnVisualOffset;
                            z = P_minZ + Math.random() * (P_maxZ - P_minZ); // Random Z along the visible height
                            break;
                        case 3: // Spawn just RIGHT of the right visible edge (maxX)
                            x = P_maxX + spawnVisualOffset;
                            z = P_minZ + Math.random() * (P_maxZ - P_minZ);
                            break;
                    }
                    tempSpawnPosition.set(x, 0, z); // CHANGED: spawnPosition -> tempSpawnPosition
                }
            }
            // --- End Spawn Position Calculation ---



            // --- Radius/Height Calculation ---
            // Use geometry parameters directly where possible for accuracy
            if (geometry instanceof THREE.SphereGeometry ||
                geometry instanceof THREE.IcosahedronGeometry ||
                geometry instanceof THREE.OctahedronGeometry ||
                geometry instanceof THREE.DodecahedronGeometry ||
                geometry instanceof THREE.TetrahedronGeometry) {
                enemyMesh.radius = geometry.parameters.radius || 0.5;
                enemyMesh.height = enemyMesh.radius * 2;
                // Debug log specifically for boss geometry
                if (typeId === 'BOSS_OCTA_PRIME') console.log(`BOSS SPAWN - Geometry: ${typeData.geometryType}, Radius: ${enemyMesh.radius.toFixed(2)}, Height: ${enemyMesh.height.toFixed(2)}`);
            } else if (geometry instanceof THREE.BoxGeometry) {
                const params = geometry.parameters;
                const w = params.width || 0.8; const h = params.height || 0.8; const d = params.depth || 0.8;
                enemyMesh.radius = Math.sqrt(w * w + h * h + d * d) / 2; // Bounding sphere radius
                enemyMesh.height = h;
            } else if (geometry instanceof THREE.CylinderGeometry) {
                const params = geometry.parameters;
                const h = params.height || 1.0;
                const r_cyl = Math.max(params.radiusTop || 0.3, params.radiusBottom || 0.3);
                enemyMesh.radius = Math.sqrt(r_cyl * r_cyl + (h / 2) * (h / 2)); // Bounding sphere radius
                enemyMesh.height = h;
            } else if (geometry instanceof THREE.ConeGeometry) {
                const params = geometry.parameters;
                const h = params.height || 1.0;
                const r_cone = params.radius || 0.5;
                enemyMesh.radius = Math.sqrt(r_cone * r_cone + (h / 2) * (h / 2)); // Bounding sphere radius approximation
                enemyMesh.height = h;
            } else {
                // Fallback using computeBoundingSphere (less reliable if origin isn't center)
                console.warn(`Unhandled geometry type for radius calc: ${geometry.constructor.name}. Using computeBoundingSphere.`);
                try {
                    geometry.computeBoundingSphere();
                    if (geometry.boundingSphere && geometry.boundingSphere.radius > 0) {
                        enemyMesh.radius = geometry.boundingSphere.radius;
                    } else {
                        geometry.computeBoundingBox(); // Try bounding box as secondary fallback
                        if (geometry.boundingBox) {
                            enemyMesh.radius = geometry.boundingBox.getSize(new THREE.Vector3()).length() / 2;
                        } else {
                            enemyMesh.radius = 0.5; // Absolute fallback
                        }
                    }
                } catch (e) {
                    console.error("Error computing bounds for geometry:", e);
                    enemyMesh.radius = 0.5;
                }
                // Height fallback
                try {
                    geometry.computeBoundingBox();
                    if (geometry.boundingBox) {
                        enemyMesh.height = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
                        if (enemyMesh.height <= 0.01) enemyMesh.height = enemyMesh.radius * 2; // Use radius if height calc fails
                    } else {
                        enemyMesh.height = enemyMesh.radius * 2;
                    }
                } catch (e) {
                    enemyMesh.height = enemyMesh.radius * 2;
                }

            }
            // Final sanity check for calculated radius and height
            if (isNaN(enemyMesh.radius) || enemyMesh.radius <= 0.01) {
                console.warn(`Corrected invalid radius (NaN or <=0.01) for ${typeId}. Defaulting to 0.5.`);
                enemyMesh.radius = 0.5;
            }
            if (isNaN(enemyMesh.height) || enemyMesh.height <= 0.01) {
                console.warn(`Corrected invalid height (NaN or <=0.01) for ${typeId}. Defaulting based on radius.`);
                enemyMesh.height = enemyMesh.radius * 2;
                if (enemyMesh.height <= 0.01) enemyMesh.height = 1.0; // Absolute minimum fallback
            }
            // --- End Radius/Height Calculation ---


            // --- Calculate Y Position for the mesh AND Apply Position to Mesh ---
            let spawnY = enemyMesh.height / 2;
            // Adjust Y for Sphere Splitters based on generation (if you kept that logic)
            if (typeData.name === 'Sphere Splitter') {
                if (enemyMesh.userData && enemyMesh.userData.generation === 1) { // Original bouncer
                    spawnY = enemyMesh.radius;
                } else if (enemyMesh.userData && enemyMesh.userData.generation > 1) { // Offspring are static Y
                    spawnY = enemyMesh.radius;
                } else if (!enemyMesh.userData || !enemyMesh.userData.generation) { // If generation not yet set (e.g. first parent)
                    spawnY = enemyMesh.radius;
                }
            }
            enemyMesh.position.set(tempSpawnPosition.x, spawnY, tempSpawnPosition.z); // Apply calculated X, Z and new Y
            // --- End Y Position & Mesh Position Application ---

            // --- <<<< NEW VALIDATION STEP >>>> ---
            // Check if the calculated spawn position (considering enemy's radius) is outside WORLD_BOUNDARY
            // We use `enemySpawnRadius` which is `enemyMesh.radius`
            if (
                enemyMesh.position.x - enemySpawnRadius < -WORLD_BOUNDARY ||
                enemyMesh.position.x + enemySpawnRadius > WORLD_BOUNDARY ||
                enemyMesh.position.z - enemySpawnRadius < -WORLD_BOUNDARY ||
                enemyMesh.position.z + enemySpawnRadius > WORLD_BOUNDARY
            ) {
                // console.log(`Spawn attempt for ${typeId} at (${enemyMesh.position.x.toFixed(1)}, ${enemyMesh.position.z.toFixed(1)}) was outside WORLD_BOUNDARY. Aborting spawn.`);
                // Optionally, dispose of the created geometry and material if not spawning
                geometry.dispose();
                material.dispose();
                return; // Do not spawn this enemy
            }
            // --- <<<< END NEW VALIDATION STEP >>>> ---


            // --- Set Shadow & UserData ---
            enemyMesh.castShadow = true;
            // Calculate health/xp before assigning userData
            let calculatedBaseHealth = 8 + (playerLevel * 2.5) + (gameTime * 0.030);
            let finalHealth = calculatedBaseHealth * (typeData.healthMultiplier || 1.0);
            let finalXp = (3 + playerLevel * 1.2 + gameTime * 0.008) * (typeData.xpMultiplier || 1.0);

            // Assign ALL relevant data from typeData, using defaults where applicable
            enemyMesh.userData = {
                type: typeId,
                health: Math.max(1, finalHealth),
                xpValue: Math.max(1, Math.floor(finalXp)),
                speed: typeData.speed ?? 1.0, // Default speed if missing
                currentSpeed: typeData.speed ?? 1.0, // Initialize currentSpeed
                dropsCache: typeData.dropsCache ?? false,
                damageMultiplier: typeData.damageMultiplier ?? 1.0,
                cost: typeData.cost ?? 1,

                // --- Ability Timers & Flags ---
                isBoss: typeData.isBoss ?? false,
                attackPatterns: typeData.attackPatterns, // Will be undefined for non-bosses, handled in updateShapes
                currentAttackPattern: typeData.currentAttackPattern,
                attackState: typeData.attackState || 'MOVING',
                attackStateTimer: 0,
                attackCooldown: typeData.attackCooldown ?? 5.0,
                attackCooldownTimer: typeData.attackCooldownTimer ?? typeData.attackCooldown ?? 5.0, // Start ready

                // Pattern Specific Data
                rapidFireBursts: typeData.rapidFireBursts ?? 0,
                rapidFireBurstTimer: 0,
                rapidFireTargetPos: null,
                dashChargeTime: typeData.dashChargeTime,
                dashSpeedMultiplier: typeData.dashSpeedMultiplier,
                dashDuration: typeData.dashDuration,
                slamRadius: typeData.slamRadius,
                slamDamage: typeData.slamDamage,
                pulseChargeTime: typeData.pulseChargeTime,
                pulseRadius: typeData.pulseRadius,
                pulseDamage: typeData.pulseDamage,
                pulseColor: typeData.pulseColor,
                summonChargeTime: typeData.summonChargeTime,
                summonCount: typeData.summonCount,
                summonType: typeData.summonType,

                // Regular abilities
                distortTimer: typeData.distortTimer ?? null,
                dashTimer: typeData.dashTimer ?? null,
                isDashing: false,
                shiftTimer: typeData.shiftTimer ?? null,
                shardTimer: typeData.shardTimer ?? null,
                generation: typeData.generation ?? null,
                weaveTimer: Math.random() * Math.PI * 2,
                bounceTimer: Math.random() * Math.PI * 2
            };
            // Ensure currentSpeed is initialized correctly if not dashing
            if (!enemyMesh.userData.isDashing) {
                enemyMesh.userData.currentSpeed = enemyMesh.userData.speed;
            }
            // --- End Shadow & UserData ---

            // --- Add Scale Debug Log ---
            if (typeId === 'BOSS_OCTA_PRIME') {
                console.log(`BOSS SPAWN - Scale: (${enemyMesh.scale.x.toFixed(1)}, ${enemyMesh.scale.y.toFixed(1)}, ${enemyMesh.scale.z.toFixed(1)})`);
            }
            // --- End Scale Debug Log ---


            // --- Add to Scene and Array ---
            scene.add(enemyMesh);
            shapes.push(enemyMesh);
            // --- End Add to Scene ---
        }

        // Helper function to get screen edges on the ground plane (y=0)
        function getScreenEdgesInWorldSpace() {
            // Ensure camera and groundPlane (assumed to be at y=0 and used for raycasting) are available
            if (!camera || !groundPlane) {
                console.warn("getScreenEdgesInWorldSpace: Camera or groundPlane not available for calculation.");
                // Fallback: provide a large area around the player if critical components are missing
                const fallbackRadius = Math.min(WORLD_BOUNDARY * 0.9, 40); // A large but bounded area
                return {
                    minX: player ? player.position.x - fallbackRadius : -fallbackRadius,
                    maxX: player ? player.position.x + fallbackRadius : fallbackRadius,
                    minZ: player ? player.position.z - fallbackRadius : -fallbackRadius,
                    maxZ: player ? player.position.z + fallbackRadius : fallbackRadius,
                    valid: false // Indicate that these are fallback values
                };
            }

            const screenPointsNDC = [
                new THREE.Vector2(-1, 1),  // Top-left corner of the screen
                new THREE.Vector2(1, 1),   // Top-right
                new THREE.Vector2(-1, -1), // Bottom-left
                new THREE.Vector2(1, -1)   // Bottom-right
            ];

            const worldPoints = [];

            for (const ndc of screenPointsNDC) {
                // Use the global raycaster (ensure it's defined and available)
                raycaster.setFromCamera(ndc, camera);
                const intersectPoint = new THREE.Vector3();

                // Intersect the ray (from camera through screen corner) with the groundPlane
                if (raycaster.ray.intersectPlane(groundPlane, intersectPoint)) {
                    worldPoints.push(intersectPoint);
                } else {
                    // This case is unlikely if the camera is pointed generally towards the ground plane.
                    // If it happens, we could use a fallback (e.g., unproject far away and clamp Y).
                    // For simplicity, we'll assume intersection for now. If issues arise, this needs robust fallback.
                    // console.warn("Screen edge ray did not intersect ground plane for NDC:", ndc);
                    // Fallback: project a point far away and assume it's on the plane for calculation continuity
                    const fallbackFarPoint = new THREE.Vector3(ndc.x, ndc.y, 0.95).unproject(camera);
                    fallbackFarPoint.y = 0; // Force onto ground plane
                    worldPoints.push(fallbackFarPoint);
                }
            }

            if (worldPoints.length < 4) {
                console.error("Could not determine all screen edge points in world space. Using fallback.");
                const fallbackRadius = Math.min(WORLD_BOUNDARY * 0.9, 40);
                return {
                    minX: player ? player.position.x - fallbackRadius : -fallbackRadius,
                    maxX: player ? player.position.x + fallbackRadius : fallbackRadius,
                    minZ: player ? player.position.z - fallbackRadius : -fallbackRadius,
                    maxZ: player ? player.position.z + fallbackRadius : fallbackRadius,
                    valid: false
                };
            }

            // Determine the min/max X and Z from the intersected world points
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            worldPoints.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minZ = Math.min(minZ, p.z);
                maxZ = Math.max(maxZ, p.z);
            });

            return { minX, maxX, minZ, maxZ, valid: true };
        }

        function spawnGeometricCache(position) { /* ... as before, but will be animated ... */
            const cacheSize = cacheRadius * 1.5;
            const geometry = new THREE.DodecahedronGeometry(cacheSize, 0);
            const material = new THREE.MeshStandardMaterial({ color: 0xDAA520, emissive: 0x443300, emissiveIntensity: 0.3, roughness: 0.3, metalness: 0.4 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            const baseY = cacheSize * 0.5;
            mesh.position.y = baseY;
            mesh.castShadow = true;

            // Animation data
            mesh.userData.isOpeningCache = true;
            mesh.userData.openAnimationTimer = 0;
            mesh.userData.openAnimationDuration = 0.8; // Duration of opening animation
            mesh.userData.originalScale = mesh.scale.clone();

            const cache = { mesh: mesh, baseY: baseY, bobTimer: Math.random() * Math.PI * 2 };
            geometricCaches.push(cache);
            scene.add(mesh);
        }

        function spawnDataFragment(position, value) {
            const orbGeometry = new THREE.TetrahedronGeometry(dataFragmentRadius, 0);
            // MeshBasicMaterial is fine here as we don't need complex lighting/emissives for simple XP orbs.
            const orbMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff, // Cyan
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);

            // Ensure fragments don't spawn outside reasonable bounds (e.g., if an enemy dies right at the edge)
            const spawnX = Math.max(-WORLD_BOUNDARY + dataFragmentRadius, Math.min(WORLD_BOUNDARY - dataFragmentRadius, position.x));
            const spawnZ = Math.max(-WORLD_BOUNDARY + dataFragmentRadius, Math.min(WORLD_BOUNDARY - dataFragmentRadius, position.z));

            orbMesh.position.set(spawnX, dataFragmentRadius * 1.2, spawnZ); // Position slightly above ground

            const fragment = {
                mesh: orbMesh,
                xpValue: Math.max(1, Math.floor(value)) // Ensure XP is at least 1
            };
            dataFragments.push(fragment);
            scene.add(orbMesh);
        }

        const megaDataFragmentRadius = 0.45; // Larger than normal data fragments
        const megaDataFragmentColor = 0xFF8C00; // Orange

        function spawnMegaDataFragment(xpAmount) {
            if (!player || xpAmount <= 0) return;

            const orbGeometry = new THREE.IcosahedronGeometry(megaDataFragmentRadius, 0); // A bit more complex
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: megaDataFragmentColor,
                emissive: new THREE.Color(megaDataFragmentColor).multiplyScalar(0.6),
                emissiveIntensity: 0.8,
                roughness: 0.4,
                metalness: 0.2,
                flatShading: true
            });
            const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);

            // Spawn somewhat near the player, e.g., in a random direction 3-6 units away
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 3 + Math.random() * 3;
            let spawnX = player.position.x + Math.cos(angle) * spawnDist;
            let spawnZ = player.position.z + Math.sin(angle) * spawnDist;

            // Clamp to world boundaries
            spawnX = Math.max(-WORLD_BOUNDARY + megaDataFragmentRadius, Math.min(WORLD_BOUNDARY - megaDataFragmentRadius, spawnX));
            spawnZ = Math.max(-WORLD_BOUNDARY + megaDataFragmentRadius, Math.min(WORLD_BOUNDARY - megaDataFragmentRadius, spawnZ));

            orbMesh.position.set(spawnX, megaDataFragmentRadius * 1.1, spawnZ); // Position slightly above ground

            const fragment = {
                mesh: orbMesh,
                xpValue: Math.max(1, Math.floor(xpAmount)),
                isMega: true, // Flag to identify it
                pulseTimer: Math.random() * Math.PI * 2 // For animation
            };
            megaDataFragments.push(fragment);
            scene.add(orbMesh);
            playSoundSynth('cache_open', 0.35); // Sound for mega orb appearing
        }

        function spawnRepairNode() {
            const pickupSize = repairNodeRadius * 2;
            const barWidth = pickupSize * 0.25;

            const geometry1 = new THREE.BoxGeometry(pickupSize, barWidth, barWidth);
            const geometry2 = new THREE.BoxGeometry(barWidth, pickupSize, barWidth);
            // MeshBasicMaterial for simple, unlit cross. Opacity used for pulsing.
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00, // Bright green
                transparent: true,
                opacity: 0.85 // Initial opacity
            });

            const mesh1 = new THREE.Mesh(geometry1, material);
            const mesh2 = new THREE.Mesh(geometry2, material);

            const group = new THREE.Group();
            group.add(mesh1);
            group.add(mesh2);

            // Spawn within a slightly smaller radius than the world boundary to avoid edge cases
            const spawnPlayableRadius = WORLD_BOUNDARY * 0.85;
            const spawnDist = 10 + Math.random() * (spawnPlayableRadius - 10);
            const angle = Math.random() * Math.PI * 2;

            // Calculate spawn relative to player, but then clamp to world boundaries
            let spawnX = player.position.x + Math.cos(angle) * spawnDist;
            let spawnZ = player.position.z + Math.sin(angle) * spawnDist;

            spawnX = Math.max(-WORLD_BOUNDARY + pickupSize, Math.min(WORLD_BOUNDARY - pickupSize, spawnX));
            spawnZ = Math.max(-WORLD_BOUNDARY + pickupSize, Math.min(WORLD_BOUNDARY - pickupSize, spawnZ));

            group.position.set(spawnX, pickupSize * 0.5 + 0.2, spawnZ); // Position slightly above ground

            const pickup = {
                mesh: group,
                shieldValue: 30, // Increased from 25 for horde mode
                pulseTimer: Math.random() * Math.PI * 2 // For animation sync
            };
            repairNodes.push(pickup);
            scene.add(group);
        }

        function spawnEnergyCore() {
            const geometry = new THREE.OctahedronGeometry(energyCoreRadius, 0);
            // MeshBasicMaterial, wireframe for a "digital energy" look. Opacity for pulsing.
            const material = new THREE.MeshBasicMaterial({
                color: 0xcc00cc, // Purple/Magenta
                transparent: true,
                opacity: 0.9,    // Initial opacity
                wireframe: true
            });
            const mesh = new THREE.Mesh(geometry, material);

            const spawnPlayableRadius = WORLD_BOUNDARY * 0.85;
            const spawnDist = 10 + Math.random() * (spawnPlayableRadius - 10);
            const angle = Math.random() * Math.PI * 2;

            let spawnX = player.position.x + Math.cos(angle) * spawnDist;
            let spawnZ = player.position.z + Math.sin(angle) * spawnDist;

            spawnX = Math.max(-WORLD_BOUNDARY + energyCoreRadius, Math.min(WORLD_BOUNDARY - energyCoreRadius, spawnX));
            spawnZ = Math.max(-WORLD_BOUNDARY + energyCoreRadius, Math.min(WORLD_BOUNDARY - energyCoreRadius, spawnZ));

            mesh.position.set(spawnX, energyCoreRadius + 0.2, spawnZ); // Position slightly above ground

            const pickup = {
                mesh: mesh,
                xpValue: 45 + playerLevel * 12, // Slightly increased XP value
                pulseTimer: Math.random() * Math.PI * 2
            };
            energyCores.push(pickup);
            scene.add(mesh);
        }

        function spawnSplitterOffspring(position, generation) {
            if (generation >= 3) return;
            const typeData = ENEMY_TYPES.SPHERE_SPLITTER;
            const newRadius = Math.max(0.2, (typeData.size[0] / (generation + 1)));
            const healthFactor = typeData.healthMultiplier || 1;
            const health = Math.max(3, (5 + playerLevel * 1.5 + gameTime * 0.02) * healthFactor / (generation * 1.5 + 1));
            const xp = Math.max(1, (3 + playerLevel * 1.0 + gameTime * 0.005) * typeData.xpMultiplier / (generation * 1.5 + 1));
            const speed = typeData.speed * (1 + generation * 0.15);
            const geometry = new THREE.SphereGeometry(newRadius, 8, 6);
            const material = new THREE.MeshStandardMaterial({ color: typeData.color, transparent: true, opacity: 0.65 + generation * 0.1, roughness: 0.7 });
            material.originalEmissiveHex = material.emissive ? material.emissive.getHex() : 0x000000;
            const slimeMesh = new THREE.Mesh(geometry, material);
            slimeMesh.position.copy(position);
            slimeMesh.position.y = newRadius; // Set Y based on actual new radius - REMAINS STATIC
            slimeMesh.castShadow = true;
            slimeMesh.position.x += (Math.random() - 0.5) * 0.6;
            slimeMesh.position.z += (Math.random() - 0.5) * 0.6;
            slimeMesh.userData = {
                type: 'SPHERE_SPLITTER',
                health: health,
                xpValue: xp,
                speed: speed,
                currentSpeed: speed,
                dropsCache: false,
                generation: generation + 1,
                // bounceTimer: Math.random() * Math.PI, // << REMOVE or comment out
                damageMultiplier: typeData.damageMultiplier * 0.8
            };
            slimeMesh.radius = newRadius;
            slimeMesh.height = newRadius * 2;
            scene.add(slimeMesh);
            shapes.push(slimeMesh);
        }

        function checkCollisions() {
            if (!player) return;

            const projectilesToRemove = new Set();
            const shapesToRemove = new Set();
            const repairNodesToRemove = new Set();
            const energyCoresToRemove = new Set();
            const dataFragmentsToRemove = new Set();
            const megaDataFragmentsToRemove = new Set(); // <<< --- ADD THIS LINE ---

            // Clear spatial grid for this frame
            spatialGrid.clear();

            // Add shapes to spatial grid
            shapes.forEach((shape, sIndex) => {
                if (shape && shape.userData && shape.parent) {
                    spatialGrid.addObject({ shape, index: sIndex }, shape.position);
                }
            });

            // Add projectiles to spatial grid
            projectiles.forEach((projectile, pIndex) => {
                if (projectile && projectile.mesh) {
                    spatialGrid.addObject({ projectile, index: pIndex }, projectile.mesh.position);
                }
            });

            // Add pickups to spatial grid
            dataFragments.forEach((fragment, index) => {
                if (fragment && fragment.mesh) {
                    spatialGrid.addObject({ dataFragment: fragment, index: index }, fragment.mesh.position);
                }
            });

            megaDataFragments.forEach((fragment, index) => {
                if (fragment && fragment.mesh) {
                    spatialGrid.addObject({ megaDataFragment: fragment, index: index }, fragment.mesh.position);
                }
            });

            repairNodes.forEach((node, index) => {
                if (node && node.mesh) {
                    spatialGrid.addObject({ repairNode: node, index: index }, node.mesh.position);
                }
            });

            energyCores.forEach((core, index) => {
                if (core && core.mesh) {
                    spatialGrid.addObject({ energyCore: core, index: index }, core.mesh.position);
                }
            });

            geometricCaches.forEach((cache, index) => {
                if (cache && cache.mesh && !cache.mesh.userData.isOpeningCache) {
                    spatialGrid.addObject({ geometricCache: cache, index: index }, cache.mesh.position);
                }
            });

            // 1. Projectiles Logic
            projectiles.forEach((projectile, pIndex) => {
                if (!projectile || !projectile.mesh || projectilesToRemove.has(pIndex)) return;

                // A. Enemy projectile hitting player
                if (projectile.isEnemyProjectile) {
                    if (player.position.distanceTo(projectile.mesh.position) < playerRadius + projectileRadius) { // Ensure projectileRadius is defined for enemy projectiles
                        playerShield -= projectile.damage;
                        createHitEffect(player, 0xff3333, 0.15);
                        projectilesToRemove.add(pIndex);
                        playSoundSynth('player_hit', 0.6);
                        if (playerShield <= 0 && currentGameState === GameState.Playing) gameOver();
                    }
                    return; // Skip to next projectile if it was an enemy one
                }

                // B. Player projectile hitting an enemy - use spatial grid for optimization
                const nearbyObjects = spatialGrid.getObjectsNear(projectile.mesh.position, projectileRadius * 2);

                for (const obj of nearbyObjects) {
                    // Skip if not a shape or already processed
                    if (!obj.shape || !obj.shape.userData || shapesToRemove.has(obj.index) || 
                        projectile.hitEnemies.has(obj.index) || !obj.shape.parent) {
                        continue;
                    }

                    const shape = obj.shape;
                    const sIndex = obj.index;

                    const shapeRadius = shape.radius || 0.5; // Use the pre-calculated radius from spawnEnemyByType
                    const distance = projectile.mesh.position.distanceTo(shape.position);
                    const collisionThreshold = projectileRadius + shapeRadius; // Ensure global projectileRadius is appropriate

                    if (distance < collisionThreshold) {
                        let damageDealt = projectile.damage * baseDamageMultiplier; // Apply meta damage upgrade

                        // --- Calculate Critical Hit ---
                        const isCrit = Math.random() < playerCritChance; // Use player's calculated crit chance
                        if (isCrit) {
                            damageDealt *= playerCritDamageMultiplier; // Apply critical damage multiplier
                        }
                        // --- End Critical Hit Calculation ---

                        shape.userData.health -= damageDealt;
                        projectile.hitEnemies.add(sIndex); // Mark enemy as hit by this projectile instance
                        playSoundSynth('enemy_hit', 0.3, { pitch: 220 + Math.random() * 50 });
                        createDamageNumber(shape.position, damageDealt, isCrit); // Pass the isCrit flag

                        if (projectile.onHit) { // Call specific onHit behavior if defined for the projectile
                            projectile.onHit(shape, projectile);
                        } else {
                            createHitEffect(shape); // Default hit effect
                        }


                        if (!projectile.tags?.includes('piercing')) {
                            projectilesToRemove.add(pIndex); // Remove non-piercing projectiles on hit
                        }

                        if (shape.userData.health <= 0) {
                            shapesToRemove.add(sIndex);
                            score += Math.max(1, Math.floor((shape.userData.xpValue || 1) * 0.7)); // Grant score

                            const typeDataOnDeath = ENEMY_TYPES[shape.userData.type]; // Get typeData for death drops
                            let droppedCurrency = false;
                            if (typeDataOnDeath && typeDataOnDeath.currencyDrop && typeDataOnDeath.currencyDrop > 0) {
                                const dropAmount = typeDataOnDeath.currencyDrop + Math.floor(Math.random() * (typeDataOnDeath.currencyDrop * 0.2));
                                dataCores += dropAmount;
                                droppedCurrency = true;
                            } else if (typeDataOnDeath && typeDataOnDeath.cost >= 5 && Math.random() < 0.15) { // Elite drop chance
                                const dropAmount = 1 + Math.floor(Math.random() * 3);
                                dataCores += dropAmount;
                                droppedCurrency = true;
                            }
                            if (droppedCurrency) updateUI(); // Update currency display


                            if (shape.userData.dropsCache && Math.random() < 0.25) {
                                spawnGeometricCache(shape.position);
                            } else if (shape.userData.type === 'SPHERE_SPLITTER') {
                                spawnSplitterOffspring(shape.position, shape.userData.generation || 1);
                                spawnSplitterOffspring(shape.position, shape.userData.generation || 1);
                            } else if (typeDataOnDeath && typeDataOnDeath.name === 'Cone Caster' && typeDataOnDeath.deathBurstRadius) {
                                createTemporaryVisualEffect(shape.position, typeDataOnDeath.deathBurstRadius, 0xffaa00, 0.3);
                                spawnDataFragment(shape.position, shape.userData.xpValue); // Spawn XP anyway
                            } else {
                                spawnDataFragment(shape.position, shape.userData.xpValue);
                            }

                            playSoundSynth('enemy_death', 0.4, { isLarge: typeDataOnDeath?.cost >= 5 });

                            const killingWeapon = playerWeapons.find(w => w.id === projectile.weaponId);
                            if (killingWeapon && killingWeapon.id === 'ENERGY_SIPHON' && killingWeapon.getShieldRestore) {
                                playerShield = Math.min(MAX_PLAYER_SHIELD, playerShield + killingWeapon.getShieldRestore());
                                createHitEffect(player, 0x33ff33, 0.25);
                            }
                        }
                    }
                }
            });

            // --- 2. Player vs. Shapes (Enemies) - Collision Damage ---
            // Use spatial grid to find nearby shapes for player collision
            const nearbyShapes = spatialGrid.getObjectsNear(player.position, playerRadius * 2);

            for (const obj of nearbyShapes) {
                // Skip if not a shape or already processed
                if (!obj.shape || !player || !obj.shape.userData || shapesToRemove.has(obj.index) || !obj.shape.parent) {
                    continue;
                }

                const shape = obj.shape;
                const sIndex = obj.index;

                const typeData = ENEMY_TYPES[shape.userData.type];
                if (!typeData) {
                    console.warn(`CRITICAL: typeData undefined for shape.userData.type = ${shape.userData.type} during player collision check!`);
                    continue;
                }

                const shapeRadius = shape.radius || 0.5;
                const distance = player.position.distanceTo(shape.position);
                const collisionThreshold = playerRadius + shapeRadius;

                if (distance < collisionThreshold) {
                    const damageToPlayer = (typeData.damageMultiplier || 1.0) * (5 + Math.floor(gameTime / 60));
                    playerShield -= damageToPlayer;
                    createHitEffect(player, 0xff0000, 0.2);
                    playSoundSynth('player_hit', 0.6);

                    const knockbackDirection = new THREE.Vector3().subVectors(player.position, shape.position).normalize();
                    knockbackDirection.y = 0;
                    player.position.add(knockbackDirection.multiplyScalar(0.3));

                    if (shape.userData.type === 'TETRA_SWARMER') {
                        shapesToRemove.add(sIndex);
                        createBurstEffect(shape.position, 10, typeData.color || 0xffffff, 2, 0.3);
                    } else {
                        const enemyKnockbackDir = new THREE.Vector3().subVectors(shape.position, player.position).normalize();
                        enemyKnockbackDir.y = 0;
                        shape.position.add(enemyKnockbackDir.multiplyScalar(0.8));
                    }

                    if (typeData.specialAbility === 'corrupt_touch' && shape.userData.type === 'CYLINDER_CORRUPTER') {
                        corruptionEffectTimer = Math.max(corruptionEffectTimer, 5.0);
                    }

                    if (playerShield <= 0 && currentGameState === GameState.Playing) {
                        gameOver();
                        return;
                    }
                }
            }

            // --- 3. Player vs. Pickups ---
            // Use spatial grid to find nearby pickups for player collision
            const nearbyPickups = spatialGrid.getObjectsNear(player.position, Math.max(xpCollectionRadius, pickupCollectionRadius) * 1.5);

            for (const obj of nearbyPickups) {
                // Process data fragments
                if (obj.dataFragment) {
                    const fragment = obj.dataFragment;
                    const index = obj.index;

                    if (!fragment || !fragment.mesh || dataFragmentsToRemove.has(index)) continue;

                    if (player.position.distanceTo(fragment.mesh.position) < xpCollectionRadius) {
                        dataFragmentsToRemove.add(index);
                        collectXP(fragment.xpValue);
                        playSoundSynth('pickup_xp', 0.2, { pitch: 880 + Math.random() * 200 });
                    }
                }

                // Process geometric caches
                else if (obj.geometricCache) {
                    const cache = obj.geometricCache;

                    if (!cache || !cache.mesh || cache.mesh.userData.isOpeningCache) continue;

                    if (player.position.distanceTo(cache.mesh.position) < pickupCollectionRadius + cacheRadius) {
                        openGeometricCache(cache.mesh);
                    }
                }

                // Process repair nodes
                else if (obj.repairNode) {
                    const pickup = obj.repairNode;
                    const index = obj.index;

                    if (!pickup || !pickup.mesh || repairNodesToRemove.has(index)) continue;

                    if (player.position.distanceTo(pickup.mesh.position) < pickupCollectionRadius) {
                        repairNodesToRemove.add(index);
                        playerShield = Math.min(MAX_PLAYER_SHIELD, playerShield + pickup.shieldValue);
                        createHitEffect(player, 0x00cc00, 0.3);
                        playSoundSynth('pickup_health', 0.5);
                    }
                }

                // Process energy cores
                else if (obj.energyCore) {
                    const pickup = obj.energyCore;
                    const index = obj.index;

                    if (!pickup || !pickup.mesh || energyCoresToRemove.has(index)) continue;

                    if (player.position.distanceTo(pickup.mesh.position) < pickupCollectionRadius) {
                        energyCoresToRemove.add(index);
                        collectXP(pickup.xpValue);
                        createHitEffect(player, 0xdd00dd, 0.3);
                        playSoundSynth('pickup_xp', 0.25, { pitch: 660 + Math.random() * 150 });
                    }
                }

                // Process mega data fragments
                else if (obj.megaDataFragment) {
                    const fragment = obj.megaDataFragment;
                    const index = obj.index;

                    if (!fragment || !fragment.mesh || megaDataFragmentsToRemove.has(index)) continue;

                    if (player.position.distanceTo(fragment.mesh.position) < xpCollectionRadius + megaDataFragmentRadius * 0.7) {
                        megaDataFragmentsToRemove.add(index);
                        collectXP(fragment.xpValue);
                        playSoundSynth('pickup_xp', 0.45, { pitch: 330 + Math.random() * 80 });
                        createBurstEffect(fragment.mesh.position, 35, megaDataFragmentColor, 4.5, 0.6);
                    }
                }
            }


            // --- 4. Process Removals (Convert Sets to arrays and sort for safe splicing) ---

            // Projectiles
            Array.from(projectilesToRemove).sort((a, b) => b - a).forEach(i => {
                if (projectiles[i]?.mesh) { // Check if projectile still exists at this index
                    scene.remove(projectiles[i].mesh);
                    projectiles[i].mesh.geometry?.dispose(); // Safely dispose geometry
                    projectiles[i].mesh.material?.dispose(); // Safely dispose material
                }
                projectiles.splice(i, 1); // Remove from array
            });

            // Shapes (Enemies)
            Array.from(shapesToRemove).sort((a, b) => b - a).forEach(i => {
                if (shapes[i]?.userData?.type === 'BOSS_OCTA_PRIME') { // Log if boss is being removed
                    console.error(`!!! BOSS REMOVED by checkCollisions at index ${i}, gameTime ${gameTime.toFixed(2)} !!!`);
                }
                if (shapes[i]) { // Check if shape still exists at this index
                    // Create death particle burst before removing
                    createBurstEffect(shapes[i].position, 15 + Math.floor((shapes[i].radius || 0.5) * 10), shapes[i].material.color.getHex(), 3, 0.4);

                    scene.remove(shapes[i]); // Remove from scene
                    shapes[i].geometry?.dispose(); // Safely dispose geometry

                    // Handle material disposal (could be single or array)
                    if (shapes[i].material) {
                        if (Array.isArray(shapes[i].material)) {
                            shapes[i].material.forEach(mat => mat?.dispose()); // Dispose each material in array
                        } else {
                            shapes[i].material.dispose(); // Dispose single material
                        }
                    }
                }
                shapes.splice(i, 1); // Remove from array
            });

            // Data Fragments
            Array.from(dataFragmentsToRemove).sort((a, b) => b - a).forEach(i => {
                if (dataFragments[i]?.mesh) {
                    scene.remove(dataFragments[i].mesh);
                    dataFragments[i].mesh.geometry?.dispose();
                    dataFragments[i].mesh.material?.dispose();
                }
                dataFragments.splice(i, 1);
            });

            Array.from(megaDataFragmentsToRemove).sort((a, b) => b - a).forEach(i => {
                if (megaDataFragments[i]?.mesh) {
                    scene.remove(megaDataFragments[i].mesh);
                    megaDataFragments[i].mesh.geometry?.dispose();
                    megaDataFragments[i].mesh.material?.dispose();
                }
                megaDataFragments.splice(i, 1);
            });

            // Repair Nodes (Groups need special handling for children)
            Array.from(repairNodesToRemove).sort((a, b) => b - a).forEach(i => {
                if (repairNodes[i]?.mesh) {
                    // Dispose materials and geometries of children within the group
                    repairNodes[i].mesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat?.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    scene.remove(repairNodes[i].mesh); // Remove the whole group
                }
                repairNodes.splice(i, 1);
            });

            // Energy Cores
            Array.from(energyCoresToRemove).sort((a, b) => b - a).forEach(i => {
                if (energyCores[i]?.mesh) {
                    scene.remove(energyCores[i].mesh);
                    energyCores[i].mesh.geometry?.dispose();
                    energyCores[i].mesh.material?.dispose();
                }
                energyCores.splice(i, 1);
            });

            // --- End of Process Removals ---
        } // End of checkCollisions function

        function collectXP(value) {
            if (currentGameState !== GameState.Playing || isPaused) return;

            currentXP += value;
            score += Math.max(1, Math.floor(value * 0.3));

            if (currentXP >= xpToNextLevel) {
                levelUp(); // Level up sound is now triggered inside levelUp if needed
                playSoundSynth('level_up', 0.6);
            }
            updateUI();
        }

        function levelUp() {
            // --- Log current state before level up ---
            // console.log(`--- LEVEL UP TRIGGER --- Current XP: ${currentXP}, XP Needed: ${xpToNextLevel}, Player Level: ${playerLevel}`);

            // --- Core Level Up Logic ---
            currentXP -= xpToNextLevel; // Subtract the XP needed for this level
            playerLevel++;              // Increment player level
            // Calculate XP needed for the *next* level
            xpToNextLevel = Math.floor(60 * Math.pow(playerLevel, 1.15));

            // --- Log new state ---
            // console.log(`New State -> Level: ${playerLevel}, Current XP: ${currentXP}, Next Level XP: ${xpToNextLevel}`);

            // --- Change Game State & Pause ---
            previousGameState = currentGameState; // Store the state we came from (should be Playing)
            currentGameState = GameState.LevelUp;
            isPaused = true; // Pause game logic while choosing upgrades

            // --- Prepare and Show Upgrade Screen ---
            presentUpgradeOptions(); // Populate the upgrade choices
            levelUpScreenElement.style.display = 'block'; // Show the level up UI

            // --- Update UI Elements ---
            updateUI(); // Refresh score, level display, XP bar (will show progress towards NEW next level)
            updateJoystickVisibility(); // Hide joysticks while level up screen is shown

            // --- Play Sound ---
            playSoundSynth('level_up', 0.6);

            // --- Check for recursive level up (if player gained massive XP) ---
            // This usually shouldn't happen with typical XP values, but as a safeguard:
            // if (currentXP >= xpToNextLevel && playerLevel > 1) {
            //    console.log("Recursive level up detected!");
            //    // If you want multiple levelups back-to-back, you could call levelUp() again,
            //    // but that might break the upgrade screen flow. Usually, it's better
            //    // to just let the player keep the excess XP towards the next level.
            // }
        }

        function presentUpgradeOptions(count = 3) {
            upgradeOptionsElement.innerHTML = '';
            const availableUpgrades = [];
            const canOfferNewWeapon = playerWeapons.length < MAX_WEAPONS;
            const canOfferNewItem = playerItems.length < MAX_ITEMS;

            playerWeapons.forEach(weapon => { if (!weapon.isEvolved && weapon.level < weapon.maxLevel) availableUpgrades.push({ type: 'weapon_upgrade', data: weapon }); });
            playerItems.forEach(item => { if (item.level < item.maxLevel) availableUpgrades.push({ type: 'item_upgrade', data: item }); });

            if (canOfferNewWeapon) Object.values(WEAPONS).forEach(weapon => { if (weapon.level === 0 && !playerWeapons.some(pw => pw.id === weapon.id)) availableUpgrades.push({ type: 'weapon_unlock', data: weapon }); });
            if (canOfferNewItem) Object.values(ITEMS).forEach(item => { if (item.level === 0 && !playerItems.some(pi => pi.id === item.id)) availableUpgrades.push({ type: 'item_unlock', data: item }); });

            Object.values(GENERIC_UPGRADES).forEach(upgrade => availableUpgrades.push({ type: 'generic_upgrade', data: upgrade }));

            let optionsToShow = [];
            if (availableUpgrades.length === 0) {
                optionsToShow.push({ type: 'generic_upgrade', data: { id: 'XP_BOOST', name: 'Gain 50 XP', icon: '', shortDescription: "Receive a small XP bonus.", getUpgradeDescription: function () { return this.name; } } });
            } else {
                let poolToUse = availableUpgrades;
                if (!canOfferNewWeapon && !canOfferNewItem) {
                    poolToUse = availableUpgrades.filter(opt => opt.type.includes('_upgrade'));
                    if (poolToUse.length === 0) poolToUse = availableUpgrades.filter(opt => opt.type === 'generic_upgrade');
                    if (poolToUse.length === 0) poolToUse = availableUpgrades;
                }
                const shuffledPool = poolToUse.sort(() => 0.5 - Math.random());
                optionsToShow = shuffledPool.slice(0, count);
            }

            optionsToShow.forEach(optionWrapper => {
                const option = optionWrapper.data;
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('upgrade-option');
                const button = document.createElement('button');
                let baseDesc = option.getUpgradeDescription ? option.getUpgradeDescription() : defaultGetUpgradeDescription.call(option);
                let synergyHint = '';

                if (optionWrapper.type === 'weapon_unlock' || optionWrapper.type === 'weapon_upgrade') {
                    const currentWeapon = playerWeapons.find(w => w.id === option.id) || option; // Get current instance or the new one
                    if (currentWeapon.synergyItemId && ITEMS[currentWeapon.synergyItemId]) {
                        const synergyItem = ITEMS[currentWeapon.synergyItemId];
                        const playerHasSynergyItem = playerItems.some(pi => pi.id === currentWeapon.synergyItemId && pi.level > 0);
                        if (currentWeapon.level === currentWeapon.maxLevel) { // Weapon is or will be max level
                            if (playerHasSynergyItem) {
                                synergyHint = `<span class="synergy-hint">( Ready for Evo with ${synergyItem.icon})</span>`;
                            } else {
                                synergyHint = `<span class="synergy-hint needed">(Needs ${synergyItem.name} ${synergyItem.icon} to Evolve)</span>`;
                            }
                        } else if (playerWeapons.some(w => w.id === currentWeapon.id)) { // Player has the weapon but not maxed
                            synergyHint = `<span class="synergy-hint needed">(Evolves with ${synergyItem.name} ${synergyItem.icon} at Lvl ${currentWeapon.maxLevel})</span>`;
                        }
                    }
                } else if (optionWrapper.type === 'item_unlock' || optionWrapper.type === 'item_upgrade') {
                    const currentItem = playerItems.find(i => i.id === option.id) || option;
                    if (currentItem.synergyWeaponId && WEAPONS[currentItem.synergyWeaponId]) {
                        const synergyWeapon = WEAPONS[currentItem.synergyWeaponId];
                        const playerHasWeapon = playerWeapons.some(pw => pw.id === currentItem.synergyWeaponId);
                        const playerHasWeaponMaxed = playerWeapons.some(pw => pw.id === currentItem.synergyWeaponId && pw.level === pw.maxLevel && !pw.isEvolved);

                        if (playerHasWeaponMaxed) {
                            synergyHint = `<span class="synergy-hint">( Ready to Evolve ${synergyWeapon.icon})</span>`;
                        } else if (playerHasWeapon) {
                            synergyHint = `<span class="synergy-hint needed">(Evolves ${synergyWeapon.name} ${synergyWeapon.icon} at Lvl ${synergyWeapon.maxLevel})</span>`;
                        }
                        // No hint if player doesn't have the base weapon at all for an item unlock
                    }
                }
                button.innerHTML = baseDesc + synergyHint;
                button.onclick = () => selectUpgrade(optionWrapper);
                const description = document.createElement('p');
                description.classList.add('upgrade-description');
                description.textContent = option.shortDescription || "Enhances capabilities.";
                optionDiv.appendChild(button);
                optionDiv.appendChild(description);
                upgradeOptionsElement.appendChild(optionDiv);
            });
        }
        function selectUpgrade(selectedOptionWrapper) { /* ... calls updateJoystickVisibility ... */
            applyUpgradeLogic(selectedOptionWrapper); if (currentGameState === GameState.LevelUp) { levelUpScreenElement.style.display = 'none'; currentGameState = GameState.Playing; isPaused = false; updateJoystickVisibility(); }
        }
        function applyUpgradeLogic(selectedOptionWrapper) {
            if (!selectedOptionWrapper || !selectedOptionWrapper.data || !selectedOptionWrapper.type) {
                console.error("Invalid upgrade option wrapper provided:", selectedOptionWrapper);
                return;
            }

            const option = selectedOptionWrapper.data;
            const type = selectedOptionWrapper.type;

            // console.log(`Applying upgrade: Type=${type}, ID=${option.id}`); // For debugging

            if (type === 'weapon_upgrade' || type === 'weapon_unlock') {
                if (option.applyUpgrade && typeof option.applyUpgrade === 'function') {
                    option.applyUpgrade(); // This will call the weapon's specific applyUpgrade method
                } else {
                    console.warn("Weapon missing or invalid applyUpgrade function:", option.id);
                    // Fallback to a default if necessary, or handle error
                    // For now, we assume weapons use defaultApplyUpgrade or their own.
                }
            } else if (type === 'item_upgrade' || type === 'item_unlock') {
                if (option.applyUpgrade && typeof option.applyUpgrade === 'function') {
                    option.applyUpgrade(); // This will call the item's specific applyUpgrade method
                } else {
                    console.warn("Item missing or invalid applyUpgrade function:", option.id);
                    // Fallback to a default if necessary
                }
            } else if (type === 'generic_upgrade') {
                if (option.id === 'SHIELD_REPAIR') { // Updated from SHIELD_REPAIR_SMALL as well
                    playerShield = Math.min(MAX_PLAYER_SHIELD, playerShield + 30); // Using the value from GENERIC_UPGRADES
                    updateUI();
                } else if (option.id === 'SPEED_BOOST') {
                    playerSpeed += 0.5; // Apply flat speed boost
                    recalculatePlayerStats(); // Recalculate in case other items affect speed %
                } else if (option.id === 'XP_BOOST' || option.id === 'XP_BOOST_SMALL') { // Handle both sizes
                    collectXP(option.id === 'XP_BOOST' ? 50 : 30); // XP values for boosts
                } else {
                    console.warn("Unknown generic upgrade ID:", option.id);
                }
            } else {
                console.error("Unknown upgrade type:", type);
            }
            // After any upgrade, it's good to update relevant UIs and stats
            updateWeaponUI();
            updateItemUI();
            updateUI(); // General UI update
        }

        function recalculatePlayerStats() {
            // Speed
            const speedMod = getItemModifier('MOVE_SPEED');
            // BASE_PLAYER_SPEED is updated by meta upgrades, so we use it here
            playerSpeed = BASE_PLAYER_SPEED * speedMod.percent + speedMod.flat;

            // XP Collection Radius
            const radiusMod = getItemModifier('XP_PICKUP_RADIUS');
            // BASE_XP_COLLECTION_RADIUS is updated by meta upgrades
            xpCollectionRadius = BASE_XP_COLLECTION_RADIUS * radiusMod.percent + radiusMod.flat;

            // Critical Hit Chance & Damage
            // Start with base values that are NOT affected by meta upgrades directly,
            // but luck from meta upgrades WILL affect the final crit chance.
            let baseRunCritChance = 0.05; // Base 5% for the current run
            let baseRunCritDamageMultiplier = 1.5; // Base 150% damage for the current run

            // Apply luck from meta upgrades to crit chance
            // Example: metaUpgrades.luck.valuePerLevel = 0.005 means +0.5% crit chance per luck level
            baseRunCritChance += (metaUpgrades.luck.level * metaUpgrades.luck.valuePerLevel);

            // Apply item modifiers for crit chance (e.g., an item with buffType 'CRIT_CHANCE_PERCENT')
            const critChanceMod = getItemModifier('CRIT_CHANCE_PERCENT');
            let finalCritChance = baseRunCritChance * critChanceMod.percent + critChanceMod.flat;

            // Apply item modifiers for crit damage (e.g., an item with buffType 'CRIT_DAMAGE_MULTIPLIER_PERCENT')
            const critDamageMod = getItemModifier('CRIT_DAMAGE_MULTIPLIER_PERCENT');
            let finalCritDamageMultiplier = baseRunCritDamageMultiplier * critDamageMod.percent + critDamageMod.flat;

            // Store the final calculated values in the global player stat variables
            playerCritChance = Math.max(0, Math.min(1, finalCritChance)); // Clamp between 0% and 100%
            playerCritDamageMultiplier = Math.max(1.0, finalCritDamageMultiplier); // Crit damage should be at least normal damage

            // console.log("DEBUG: Player Stats Recalculated - Speed:", playerSpeed.toFixed(2),
            //             "XP Radius:", xpCollectionRadius.toFixed(2),
            //             "CritChance:", playerCritChance.toFixed(3),
            //             "CritDmgMulti:", playerCritDamageMultiplier.toFixed(2));
        }


        function checkEvolution(weaponToCheck) {
            if (!weaponToCheck || weaponToCheck.isEvolved || weaponToCheck.level < weaponToCheck.maxLevel || !weaponToCheck.synergyItemId) {
                return; // Not eligible for evolution
            }

            // Find the synergistic item in the player's inventory AND ensure it's active (level > 0)
            const synergisticItem = playerItems.find(item => item.id === weaponToCheck.synergyItemId && item.level > 0);

            if (synergisticItem) {
                // console.log(`DEBUG: Synergy condition met for ${weaponToCheck.id} with ${synergisticItem.id}!`);
                const evolvedData = EVOLVED_WEAPONS[weaponToCheck.id]; // Assumes weaponToCheck.id matches the key in EVOLVED_WEAPONS

                if (evolvedData) {
                    // console.log(`DEBUG: Evolving ${weaponToCheck.id} to ${evolvedData.name}!`);
                    const weaponIndex = playerWeapons.findIndex(w => w.id === weaponToCheck.id);

                    if (weaponIndex !== -1) {
                        // Create a new object for the evolved weapon to avoid modifying the template
                        // and to ensure it gets its own instance properties (like fireTimer)
                        const evolvedWeaponInstance = {
                            ...evolvedData, // Spread properties from the evolved template
                            // Explicitly assign functions if they are defined on the template
                            fire: evolvedData.fire,
                            getFireRate: evolvedData.getFireRate,
                            getDamage: evolvedData.getDamage,
                            getProjectileCount: evolvedData.getProjectileCount,
                            getRadius: evolvedData.getRadius, // For AOE/Pulse
                            getShapeCount: evolvedData.getShapeCount, // For Orbitals
                            getUpgradeDescription: evolvedData.getUpgradeDescription || defaultGetUpgradeDescription, // Fallback
                            createMesh: evolvedData.createMesh,
                            updateMesh: evolvedData.updateMesh,
                            updateWeaponSystem: evolvedData.updateWeaponSystem,
                            // Reset instance-specific timers/states
                            fireTimer: 0,
                            damageTimer: 0, // For weapons like Orbital Shield
                            enemiesHitThisInterval: [] // For weapons like Orbital Shield
                        };

                        // Remove the old weapon's persistent mesh if it exists
                        if (playerWeapons[weaponIndex].id && persistentWeaponMeshes[playerWeapons[weaponIndex].id]) {
                            scene.remove(persistentWeaponMeshes[playerWeapons[weaponIndex].id]);
                            delete persistentWeaponMeshes[playerWeapons[weaponIndex].id];
                        }

                        playerWeapons[weaponIndex] = evolvedWeaponInstance;

                        // If the evolved weapon has a mesh creation function, call it
                        if (evolvedWeaponInstance.createMesh) {
                            evolvedWeaponInstance.createMesh(evolvedWeaponInstance);
                        }
                        updateWeaponUI(); // Update UI to show evolved weapon
                        // Potentially play a sound or show a visual effect for evolution
                        createBurstEffect(player.position, 60, 0xFFD700, 7, 1.0, 'spiral');

                    } else {
                        console.error(`DEBUG: Cannot find weapon ${weaponToCheck.id} in player inventory to evolve.`);
                    }
                } else {
                    console.warn(`DEBUG: No evolution definition found in EVOLVED_WEAPONS for weapon ID: ${weaponToCheck.id}`);
                }
            }
        }

        function openGeometricCache(collectedCacheMesh) {
            if (!collectedCacheMesh || collectedCacheMesh.userData.isOpeningCache) return;

            initializeAudio(); // Ensure audio is ready
            playSoundSynth('cache_open', 0.5); // Play sound when opening starts

            createBurstEffect(collectedCacheMesh.position, 20, 0xFFD700, 3, 0.4);

            collectedCacheMesh.userData.isOpeningCache = true;
            collectedCacheMesh.userData.openAnimationTimer = 0;
            collectedCacheMesh.userData.openAnimationDuration = 0.8;
            if (collectedCacheMesh.scale) {
                collectedCacheMesh.userData.originalScale = collectedCacheMesh.scale.clone();
            } else {
                collectedCacheMesh.userData.originalScale = new THREE.Vector3(1, 1, 1);
            }
        }
        function grantCacheRewards() { // Called after animation
            createBurstEffect(player.position, 50, 0xFFD700, 5, 0.8, 'spiral');
            const rewardsToGrant = [];
            const numRewards = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numRewards; i++) {
                const potentialRewards = [];
                const canOfferNewWeapon = playerWeapons.length < MAX_WEAPONS;
                const canOfferNewItem = playerItems.length < MAX_ITEMS;
                playerWeapons.forEach(w => { if (!w.isEvolved && w.level < w.maxLevel) potentialRewards.push({ type: 'weapon_upgrade', data: w }); });
                playerItems.forEach(item => { if (item.level < item.maxLevel) potentialRewards.push({ type: 'item_upgrade', data: item }); });
                if (canOfferNewWeapon) Object.values(WEAPONS).forEach(w => { if (w.level === 0 && !playerWeapons.some(pw => pw.id === w.id)) potentialRewards.push({ type: 'weapon_unlock', data: w }); });
                if (canOfferNewItem) Object.values(ITEMS).forEach(item => { if (item.level === 0 && !playerItems.some(pi => pi.id === item.id)) potentialRewards.push({ type: 'item_unlock', data: item }); });
                Object.values(GENERIC_UPGRADES).forEach(upg => potentialRewards.push({ type: 'generic_upgrade', data: upg }));
                potentialRewards.push({ type: 'generic_upgrade', data: { id: 'XP_BOOST_SMALL', name: 'Gain 30 XP', icon: '', shortDescription: "Receive a small XP bonus.", getUpgradeDescription: function () { return this.name; } } });
                potentialRewards.push({ type: 'generic_upgrade', data: { id: 'SHIELD_REPAIR_SMALL', name: 'Repair 15 Shield', icon: '', shortDescription: "Instantly restores 15 shield.", getUpgradeDescription: function () { return this.name; } } });
                if (potentialRewards.length > 0) {
                    const selectedReward = potentialRewards[Math.floor(Math.random() * potentialRewards.length)];
                    rewardsToGrant.push(selectedReward);
                }
            }
            cacheRewardsListElement.innerHTML = '';
            rewardsToGrant.forEach(rewardWrapper => {
                const reward = rewardWrapper.data;
                const rewardSpan = document.createElement('span');
                rewardSpan.classList.add('reward-item');
                rewardSpan.textContent = reward.icon || '?';
                cacheRewardsListElement.appendChild(rewardSpan);
                applyUpgradeLogic(rewardWrapper);
            });
            cacheRewardPopupElement.style.opacity = 1;
            cacheRewardPopupElement.style.display = 'block';
            setTimeout(() => {
                cacheRewardPopupElement.style.opacity = 0;
                setTimeout(() => { cacheRewardPopupElement.style.display = 'none'; }, 500);
            }, 2500);
            updateWeaponUI(); updateItemUI(); updateUI();
        }



        function gameOver() {
            if (currentGameState === GameState.GameOver || currentGameState === GameState.Win) return;
            playSoundSynth('error', 0.5); // Play a game over sound?
            saveData(); // Save currency/meta upgrades
            previousGameState = currentGameState;
            currentGameState = GameState.GameOver;
            isPaused = true;
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'block';
            updateJoystickVisibility();
        }
        function winGame() {
            if (currentGameState === GameState.Win || currentGameState === GameState.GameOver) return;
            playSoundSynth('level_up', 0.7); // Play a win sound?
            saveData(); // Save currency/meta upgrades
            previousGameState = currentGameState;
            currentGameState = GameState.Win;
            isPaused = true;
            winFinalScoreElement.textContent = score;
            winScreenElement.style.display = 'block';
            updateJoystickVisibility();
        }
        function onWindowResize() { /* ... as before, update joystick radii if needed ... */
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Update joystick radii based on new screen size if their areas are percentage-based
            joystickRadius = joystickArea.offsetWidth / 2 || 75;
            knobRadius = joystickKnob.offsetWidth / 2 || 30;
            aimJoystickRadius = aimJoystickArea.offsetWidth / 2 || 75;
            aimKnobRadius = aimJoystickKnob.offsetWidth / 2 || 30;
        }
        function createHitEffect(targetMesh, hitColor = 0xffffff, duration = 0.15) {
            if (!targetMesh || !targetMesh.material || hitEffects.some(e => e.target === targetMesh && e.timer > 0)) {
                // Don't apply new effect if one is already active and hasn't faded
                return;
            }

            const material = targetMesh.material;
            // Ensure matInstance is the actual material, not an array if multi-material object
            const matInstance = Array.isArray(material) ? material[0] : material;
            if (!matInstance) return;

            let originalColorValueHex;
            let isEmissiveMaterial = false;
            const originalOpacity = matInstance.opacity !== undefined ? matInstance.opacity : 1.0; // Store original opacity

            // Check if the material is one that supports emissive properties
            if (matInstance.emissive && matInstance.emissive.isColor) {
                isEmissiveMaterial = true;
                // Store original emissive, or black if it wasn't set (to return to non-emissive)
                originalColorValueHex = matInstance.originalEmissiveHex !== undefined ? matInstance.originalEmissiveHex : matInstance.emissive.getHex();
                matInstance.originalEmissiveHex = originalColorValueHex; // Store it on the material instance
                matInstance.emissive.setHex(hitColor);
                if (matInstance.emissiveIntensity !== undefined) {
                    matInstance.originalEmissiveIntensity = matInstance.emissiveIntensity; // Store original
                    matInstance.emissiveIntensity = (matInstance.originalEmissiveIntensity || 0.5) + 0.5; // Boost intensity
                }
            } else if (matInstance.color && matInstance.color.isColor) { // For MeshBasicMaterial or others without emissive
                originalColorValueHex = matInstance.originalColorHex !== undefined ? matInstance.originalColorHex : matInstance.color.getHex();
                matInstance.originalColorHex = originalColorValueHex; // Store it on the material instance
                matInstance.color.setHex(hitColor);
                // For MeshBasicMaterial, we might pulse opacity if we want a "flash"
                if (matInstance.transparent !== undefined && matInstance.opacity !== undefined) {
                    matInstance.oldTransparent = matInstance.transparent;
                    matInstance.transparent = true;
                    matInstance.opacity = Math.min(1, originalOpacity + 0.3);
                }
            } else {
                // Material doesn't have a standard color or emissive property to easily flash
                return;
            }

            hitEffects.push({
                target: targetMesh,
                originalColor: originalColorValueHex,
                originalOpacity: originalOpacity,
                originalEmissiveIntensity: isEmissiveMaterial && matInstance.emissiveIntensity !== undefined ? matInstance.originalEmissiveIntensity : null,
                oldTransparent: matInstance.oldTransparent, // Store for MeshBasicMaterial opacity flash
                timer: duration,
                duration: duration, // Store full duration for fading logic
                isEmissive: isEmissiveMaterial
            });
        }

        function onMouseMove(event) {
            // If you want mouse to have NO effect on aiming:
            // return;

            // If you want mouse to aim ONLY on desktop (isTouchDevice is false)
            if (isTouchDevice) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // The actual raycasting part for mouse aim would be here IF updateAimTarget used it.
            // Since updateAimTarget is now fully auto, this mouse vector isn't directly used for aimTarget.
            // However, some UI elements or future features might still use `mouse`.
        }

        function onKeyDown(event) {
            // Universal Pause/Menu Key
            if (event.code === 'KeyP' || event.code === 'Escape') {
                event.preventDefault(); // Prevent default browser action for Escape
                if (currentGameState === GameState.Playing && !isPaused) {
                    pauseGame();
                } else if (currentGameState === GameState.Paused) {
                    resumeGame();
                } else if (currentGameState === GameState.Settings) {
                    hideSettings();
                } else if (currentGameState === GameState.EvolutionBook) {
                    hideEvolutionBook();
                } else if (currentGameState === GameState.LevelSelect) {
                    hideLevelSelect();
                } else if (currentGameState === GameState.LevelUp) {
                    // Optionally allow Esc to close level up, but this might be confusing
                    // selectUpgrade(null); // Pass null or a default if you want to skip upgrade
                }
                return;
            }

            // Movement keys only if playing, not paused, and movement joystick is not active (or not on touch device)
            if (currentGameState === GameState.Playing && !isPaused && (!joystickActive || !isTouchDevice)) {
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp':
                        moveState.forward = 1; break;
                    case 'KeyS': case 'ArrowDown':
                        moveState.backward = 1; break;
                    case 'KeyA': case 'ArrowLeft':
                        moveState.left = 1; break;
                    case 'KeyD': case 'ArrowRight':
                        moveState.right = 1; break;
                }
            }
        }

        function onKeyUp(event) {
            // This can apply regardless of joystick state for keyboard users
            switch (event.code) {
                case 'KeyW': case 'ArrowUp':
                    moveState.forward = 0; break;
                case 'KeyS': case 'ArrowDown':
                    moveState.backward = 0; break;
                case 'KeyA': case 'ArrowLeft':
                    moveState.left = 0; break;
                case 'KeyD': case 'ArrowRight':
                    moveState.right = 0; break;
            }
        }
        function createTemporaryVisualEffect(position, radius, color, duration, wireframe = false, geometry = null) { /* ... as before ... */ }

        function setupLevel1Map() {
            // Dispose of previous static objects if they exist
            staticLevelObjects.forEach(obj => {
                if (obj.parent) scene.remove(obj);
                obj.geometry?.dispose();
                obj.material?.dispose();
            });
            staticLevelObjects.length = 0; // Clear the array

            const mapBoundary = WORLD_BOUNDARY * 0.95; // Obstacles inside this boundary

            // --- Decorative Background Elements (Optional - keep if desired, ensure no collision) ---
            // If you want purely visual distant structures, uncomment and adjust this.
            // Make sure they have no userData.isObstacle = true and are far away.
            /*
            const structureColors = [0x334155, 0x475569, 0x52525b];
            for (let i = 0; i < 10; i++) { // Reduced count
            const size = Math.random() * 20 + 15; // Larger size
            let geom; const type = Math.random();
            if (type < 0.33) geom = new THREE.BoxGeometry(size, Math.random() * 40 + 30, size);
            else if (type < 0.66) geom = new THREE.CylinderGeometry(size/2, size/2, Math.random() * 50 + 25, Math.floor(Math.random()*4+4));
            else geom = new THREE.ConeGeometry(size/2, Math.random() * 50 + 30, Math.floor(Math.random()*4+4));
            const mat = new THREE.MeshStandardMaterial({ color: structureColors[Math.floor(Math.random() * structureColors.length)], roughness: 0.9, metalness: 0.05, flatShading: true });
            const mesh = new THREE.Mesh(geom, mat);
            const angle = Math.random() * Math.PI * 2;
            const dist = mapBoundary * 1.5 + Math.random() * mapBoundary * 0.5; // Place them further out
            mesh.position.set( player.position.x + Math.cos(angle) * dist, geom.parameters.height / 2 - 10, player.position.z + Math.sin(angle) * dist ); // Place lower
            mesh.rotation.y = Math.random() * Math.PI * 2;
            mesh.receiveShadow = false; // Don't need shadows this far
            mesh.castShadow = false;
            scene.add(mesh);
            staticLevelObjects.push(mesh); // Add to array for cleanup, but NOT marked as obstacle
            }
            */

            // --- Playable Obstacles (Spheres, Octahedrons, Dodecahedrons only) ---
            const obstacleColors = [0x71717a, 0x64748b, 0x4a5568, 0x52525b];
            const obstacleCount = 30 + Math.floor(Math.random() * 10); // Keep similar density
            for (let i = 0; i < obstacleCount; i++) {
                const sizeBase = Math.random() * 2.5 + 1.5; // Keep obstacle size range
                let geom;
                const type = Math.random(); // Random value between 0.0 and 1.0
                let obstacleRadius;

                // Distribute remaining shapes: Sphere (33%), Octahedron (33%), Dodecahedron (34%)
                if (type < 0.33) { // Spheres
                    obstacleRadius = sizeBase / 1.8 * (0.9 + Math.random() * 0.2);
                    geom = new THREE.SphereGeometry(obstacleRadius, Math.floor(Math.random() * 2 + 6), Math.floor(Math.random() * 2 + 6));
                } else if (type < 0.66) { // Octahedrons
                    obstacleRadius = sizeBase / 1.7 * (0.9 + Math.random() * 0.2);
                    geom = new THREE.OctahedronGeometry(obstacleRadius, 0);
                } else { // Dodecahedrons
                    obstacleRadius = sizeBase / 1.7 * (0.9 + Math.random() * 0.2);
                    geom = new THREE.DodecahedronGeometry(obstacleRadius, 0);
                }

                const mat = new THREE.MeshStandardMaterial({
                    color: obstacleColors[Math.floor(Math.random() * obstacleColors.length)],
                    roughness: 0.5 + Math.random() * 0.2,
                    metalness: 0.1 + Math.random() * 0.2,
                    wireframe: Math.random() < 0.05
                });
                const mesh = new THREE.Mesh(geom, mat);

                const angle = Math.random() * Math.PI * 2;
                // Ensure obstacles don't spawn too close to the center (0,0) where player starts
                const minDist = 8;
                const maxDist = mapBoundary * 0.9;
                const dist = minDist + Math.random() * (maxDist - minDist);

                // Calculate spawn position relative to world origin, not player (player starts at origin)
                const spawnX = Math.cos(angle) * dist;
                const spawnZ = Math.sin(angle) * dist;
                // Calculate Y position based on geometry radius (since all are roughly spherical)
                const spawnY = obstacleRadius + 0.05; // Place base slightly above ground

                mesh.position.set(spawnX, spawnY, spawnZ);
                mesh.rotation.set(Math.random() * 0.1, Math.random() * Math.PI, Math.random() * 0.1); // Subtle random rotation
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                // Mark as obstacle for collision detection
                mesh.userData.isObstacle = true;
                mesh.userData.obstacleRadius = obstacleRadius; // Store the calculated radius

                scene.add(mesh);
                staticLevelObjects.push(mesh); // Add to array for collision checks and cleanup
            }
        }

        // --- Touch Controls Setup & Fullscreen ---
        function updateJoystickVisibility() {
            const showMovementJoystick = isTouchDevice && currentGameState === GameState.Playing && !isPaused;

            // Condition for showing the top-right button:
            // - On touch device: show if Playing or Paused (it's the pause/resume button)
            // - On non-touch device: always show (it's the fullscreen button)
            const showTopRightButton =
                (isTouchDevice && (currentGameState === GameState.Playing || currentGameState === GameState.Paused)) ||
                (!isTouchDevice);

            if (joystickArea) joystickArea.style.display = showMovementJoystick ? 'block' : 'none';

            if (fullscreenButton) {
                fullscreenButton.style.display = showTopRightButton ? 'block' : 'none';

                if (showTopRightButton) { // Only update text if button is visible
                    if (isTouchDevice) {
                        // On mobile, it's a pause/resume button
                        if (currentGameState === GameState.Playing && !isPaused) {
                            fullscreenButton.textContent = ""; // Hamburger icon for "Menu/Pause"
                        } else if (currentGameState === GameState.Paused) {
                            fullscreenButton.textContent = ""; // Play icon for "Resume"
                        }
                        // If you wanted it visible in other mobile states, you'd add more conditions here.
                    } else {
                        // On desktop, it's a fullscreen toggle button
                        if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                            fullscreenButton.textContent = "Exit FS";
                        } else {
                            fullscreenButton.textContent = "Fullscreen";
                        }
                    }
                }
            }
        }
        function setupTouchControls() {
            if (joystickArea) { // Ensure elements exist before getting offsetWidth
                joystickRadius = joystickArea.offsetWidth / 2 || 75; // Default for landscape
                knobRadius = joystickKnob.offsetWidth / 2 || 30;   // Default for landscape

                // Adjust for portrait if needed, though CSS media queries are better for this
                if (window.innerHeight > window.innerWidth && joystickArea.offsetHeight > 0) { // Portrait check
                    // Use offsetHeight if it's more representative in portrait, or keep as is
                    // joystickRadius = joystickArea.offsetHeight / 2;
                    // knobRadius = joystickKnob.offsetHeight / 2;
                }
            }
            // No need for aimJoystickArea related calculations

            updateJoystickVisibility(); // This will now only show the single joystick on mobile
            document.body.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.body.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.body.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.body.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        }
        function handleTouchStart(event) {
            let targetElement = event.target;
            // Check if touch is on a UI button or menu overlay
            while (targetElement != null) {
                if (targetElement.tagName === 'BUTTON' ||
                    targetElement.id === 'fullscreen-button' ||
                    (targetElement.classList &&
                        (targetElement.classList.contains('menu-box') ||
                            targetElement.classList.contains('popup-overlay') ||
                            targetElement.classList.contains('level-button') // Added level button
                        )
                    )
                ) {
                    return; // Don't process joystick if touch is on UI
                }
                targetElement = targetElement.parentElement;
            }

            if (currentGameState === GameState.Playing && !isPaused && isTouchDevice) {
                event.preventDefault(); // Prevent default only if it's a game touch
                const touches = event.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];

                    // Only activate movement joystick if not already active
                    if (!joystickActive) {
                        const touchX = touch.clientX;
                        const touchY = touch.clientY;

                        // Check if touch is within the joystick's general vicinity (e.g., bottom half of screen)
                        // This makes it easier to activate if the CSS positioning isn't pixel-perfectly hit.
                        // For a centered joystick, the main check is !joystickActive.
                        // The joystickArea.style.left/top lines are now mainly for visual feedback if you
                        // want the joystick base to dynamically appear under the finger on first touch.
                        // If joystick is fixed position (as per CSS), these lines can be removed.

                        joystickActive = true;
                        joystickPointerId = touch.identifier;

                        // If joystick is fixed, these lines for moving the base are not strictly needed.
                        // They can be useful if you want the joystick base to "snap" to initial touch.
                        // joystickArea.style.left = (touchX - joystickRadius) + 'px';
                        // joystickArea.style.top = (touchY - joystickRadius) + 'px';

                        // Calculate initial knob position based on touch relative to the (now centered) joystickArea
                        const joystickRect = joystickArea.getBoundingClientRect();
                        joystickBaseX = joystickRect.left + joystickRadius; // Center of the joystick area
                        joystickBaseY = joystickRect.top + joystickRadius;  // Center of the joystick area

                        // Update knob based on current touch relative to joystickArea center
                        let deltaX = touchX - joystickBaseX;
                        let deltaY = touchY - joystickBaseY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = joystickRadius - knobRadius;
                        if (distance > maxDistance) {
                            deltaX = (deltaX / distance) * maxDistance;
                            deltaY = (deltaY / distance) * maxDistance;
                        }
                        joystickKnob.style.left = (joystickRadius - knobRadius + deltaX) + 'px';
                        joystickKnob.style.top = (joystickRadius - knobRadius + deltaY) + 'px';
                        break; // Process only one touch for the movement joystick
                    }
                }
            }
        }
        function handleTouchMove(event) {
            if (currentGameState !== GameState.Playing || isPaused || !isTouchDevice) return;

            if (joystickActive) { // Only proceed if the movement joystick is active
                event.preventDefault();
                const touches = event.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];

                    if (joystickActive && touch.identifier === joystickPointerId) {
                        const touchX = touch.clientX;
                        const touchY = touch.clientY;

                        // joystickBaseX/Y should be the center of the joystickArea
                        // This needs to be updated if joystickArea can move,
                        // or use fixed values if joystickArea position is static.
                        // For a statically centered joystick:
                        const joystickRect = joystickArea.getBoundingClientRect();
                        const currentJoystickCenterX = joystickRect.left + joystickRadius;
                        const currentJoystickCenterY = joystickRect.top + joystickRadius;


                        let deltaX = touchX - currentJoystickCenterX; // Delta from center of joystick area
                        let deltaY = touchY - currentJoystickCenterY; // Delta from center of joystick area

                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = joystickRadius - knobRadius;

                        if (distance > maxDistance) {
                            deltaX = (deltaX / distance) * maxDistance;
                            deltaY = (deltaY / distance) * maxDistance;
                        }
                        joystickKnob.style.left = (joystickRadius - knobRadius + deltaX) + 'px';
                        joystickKnob.style.top = (joystickRadius - knobRadius + deltaY) + 'px';
                    }
                    // No aim joystick logic needed here
                }
            }
        }
        function handleTouchEnd(event) {
            let gameTouchEnded = false;
            const touches = event.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                if (joystickActive && touch.identifier === joystickPointerId) { // Check if active before resetting
                    joystickActive = false;
                    joystickPointerId = null;
                    // Reset knob to center of its area
                    joystickKnob.style.left = (joystickRadius - knobRadius) + 'px';
                    joystickKnob.style.top = (joystickRadius - knobRadius) + 'px';
                    gameTouchEnded = true;
                    break; // Found the movement joystick touch
                }
                // No aim joystick logic
            }

            // Only prevent default if a game-related touch (joystick) ended.
            if (gameTouchEnded && currentGameState === GameState.Playing && !isPaused && isTouchDevice) {
                // event.preventDefault(); // Generally not needed on touchend for joysticks
            }
        }

        function toggleFullScreen() { // The name is kept, but its role expands
            if (isTouchDevice) {
                // On mobile, this button now acts as a Pause/Resume button
                if (currentGameState === GameState.Playing && !isPaused) {
                    pauseGame(); // pauseGame itself calls updateJoystickVisibility
                } else if (currentGameState === GameState.Paused) {
                    resumeGame(); // resumeGame itself calls updateJoystickVisibility
                }
                return; // Exit early for touch devices, no further fullscreen logic needed
            }

            // Original Fullscreen logic for non-touch devices (Desktop)
            const elem = document.documentElement;

            if (!document.fullscreenElement &&
                !document.mozFullScreenElement &&
                !document.webkitFullscreenElement &&
                !document.msFullscreenElement) {
                // --- Enter Fullscreen ---
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => { console.error(`FS Error: ${err.message} (${err.name})`); });
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
                // console.log("Requesting fullscreen"); // Optional log
                // updateJoystickVisibility will handle text update on next call, 
                // or you can set it directly if preferred for desktop:
                // if (fullscreenButton) fullscreenButton.textContent = "Exit FS";
            } else {
                // --- Exit Fullscreen ---
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                // console.log("Exiting fullscreen"); // Optional log
                // if (fullscreenButton) fullscreenButton.textContent = "Fullscreen";
            }
            // Call updateJoystickVisibility to ensure desktop button text is correct after FS change
            if (!isTouchDevice && fullscreenButton) { // Ensure it only updates for desktop here
                if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                    fullscreenButton.textContent = "Exit FS";
                } else {
                    fullscreenButton.textContent = "Fullscreen";
                }
            }
        }
        function createBackgroundPattern() {
            // Dispose of previous pattern if it exists
            if (backgroundPattern) {
                if (backgroundPattern.parent) scene.remove(backgroundPattern);
                if (backgroundPattern.geometry) backgroundPattern.geometry.dispose();
                if (backgroundPattern.material) backgroundPattern.material.dispose();
                backgroundPattern = null; // Clear the reference
            }

            const patternVertexShader = `
        varying vec2 vUv;
        void main() {
        vUv = uv;
        // Position the background plane directly in normalized device coordinates (NDC)
        // This makes it a fullscreen quad that always faces the camera.
        // Or, for a world-space plane, use the standard projection.
        // For a simple background plane, world-space is often easier to manage with fog.
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `;
            const patternFragmentShader = `
        uniform float time;
        varying vec2 vUv;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float fogNear;
        uniform float fogFar;
        uniform vec3 fogColor;

        float random (vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        float noise (vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        vec2 u = f*f*(3.0-2.0*f); // Smoothstep
        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
        }

        void main() {
        vec2 scaledUv = vUv * 25.0; // Increased scale for more detail or smaller pattern
        float n = noise(scaledUv + vec2(time * 0.1, time * 0.15)); // Slightly different time for x/y noise offset

        // More complex pattern example:
        float wave1 = sin(scaledUv.x * cos(time*0.05) + scaledUv.y * sin(time*0.08) + n * 4.0) * 0.5 + 0.5;
        float wave2 = cos(scaledUv.y * 1.5 * sin(time*0.06) - scaledUv.x * 1.2 * cos(time*0.09) + n * 3.0) * 0.5 + 0.5;
        float pattern = smoothstep(0.3, 0.7, wave1 * wave2 + noise(scaledUv * 0.5 + time * 0.05) * 0.2);

        vec3 finalColor = mix(color1, color2, pattern);

        // Vignette effect (darker at edges of the plane)
        float distFromCenter = distance(vUv, vec2(0.5));
        float vignette = smoothstep(0.5, 0.25, distFromCenter); // Inverted: 1 at center, 0.25 at edge

        vec3 colorWithVignette = finalColor * vignette;

        // Manual fog calculation if needed (if Three.js fog doesn't apply as expected to custom shaders)
        // This requires passing cameraPosition and worldPosition of the fragment
        // For a simple background plane far away, it's often easier to let Three.js handle fog or just make it dark.
        // float fogFactor = smoothstep(fogNear, fogFar, gl_FragCoord.z / gl_FragCoord.w);
        // vec3 foggedColor = mix(colorWithVignette, fogColor, fogFactor);
        // gl_FragColor = vec4(foggedColor, 1.0);

        gl_FragColor = vec4(colorWithVignette * 0.4, 1.0); // Make it generally darker
        }
        `;

            const patternMaterial = new THREE.ShaderMaterial({
                vertexShader: patternVertexShader,
                fragmentShader: patternFragmentShader,
                uniforms: {
                    time: { value: 0.0 },
                    color1: { value: new THREE.Color(0x080510) }, // Even darker base
                    color2: { value: new THREE.Color(0x120818) }, // Darker accent
                    // For manual fog (if you enable it in shader):
                    // fogColor: { value: scene.fog.color },
                    // fogNear: { value: scene.fog.near },
                    // fogFar: { value: scene.fog.far },
                },
                side: THREE.DoubleSide,
                transparent: true, // Set to true if you want it to blend or have opacity < 1
                depthWrite: false, // Important for backgrounds
                fog: false // Explicitly disable Three.js built-in fog for this material if you handle it manually or want no fog on it
            });

            // Adjust size to be comfortably larger than the fog distance or camera far plane
            const patternSize = Math.max(WORLD_BOUNDARY * 2.5, (scene.fog && scene.fog.far ? scene.fog.far * 1.2 : WORLD_BOUNDARY * 2.5));
            const patternGeometry = new THREE.PlaneGeometry(patternSize, patternSize);
            backgroundPattern = new THREE.Mesh(patternGeometry, patternMaterial);
            backgroundPattern.rotation.x = -Math.PI / 2;
            backgroundPattern.position.y = -5; // Place it further down so it's less likely to interfere with ground grid
            backgroundPattern.renderOrder = -999; // Render very first
            scene.add(backgroundPattern);
        }

    // --- Start Game on Load ---
    window.onload = init;

    </script> <!-- This closing script tag MUST be present -->

</body> 
</html>
